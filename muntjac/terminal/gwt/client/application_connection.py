# Copyright (C) 2011 Vaadin Ltd.
# Copyright (C) 2011 Richard Lincoln
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Note: This is a modified file from Vaadin. For further information on
#       Vaadin please visit http://www.vaadin.com.

from __pyjamas__ import JS

from datetime import time, datetime

from StringIO import StringIO

import pygwt as GWT

from pyjamas import Window, History, DOM
from pyjamas.Timer import Timer

from muntjac.terminal.gwt.client.paintable import Paintable
from muntjac.terminal.gwt.client.v_tooltip import VTooltip
from muntjac.terminal.gwt.client.v_scheduler_impl import VSchedulerImpl, VSchedulerImpl
from muntjac.terminal.gwt.client.ui.v_context_menu import VContextMenu
from muntjac.terminal.gwt.client.container_resized_listener import ContainerResizedListener
from muntjac.terminal.gwt.client.util import Util
from muntjac.terminal.gwt.client.v_console import VConsole
from muntjac.terminal.gwt.client.ui.v_view import VView
from muntjac.terminal.gwt.client.application_configuration import ApplicationConfiguration
from muntjac.terminal.gwt.client.render_space import RenderSpace
from muntjac.terminal.gwt.client.ui.v_notification import VNotification, VNotification
from muntjac.terminal.gwt.client.locale_service import LocaleService
from muntjac.terminal.gwt.client.ui.field import Field
from muntjac.terminal.gwt.client.render_information import RenderInformation, FloatSize, Size
from muntjac.terminal.gwt.client.uidl import UIDL
from muntjac.terminal.gwt.client.component_locator import ComponentLocator
from muntjac.terminal.gwt.client.component_detail import ComponentDetail
from muntjac.terminal.gwt.client.component_detail_map import ComponentDetailMap
from muntjac.terminal.gwt.client.synchronous_xhr import SynchronousXHR
from muntjac.terminal.gwt.client.browser_info import BrowserInfo
from muntjac.terminal.gwt.client.ui.dd.v_drag_and_drop_manager import VDragAndDropManager
from muntjac.terminal.gwt.client.focusable import Focusable


class ApplicationConnection(object):
    """This is the client side communication "engine", managing client-server
    communication with its server side counterpart
    L{AbstractCommunicationManager}.

    Client-side widgets receive updates from the corresponding server-side
    components as calls to L{Paintable.updateFromUIDL} (not to be
    confused with the server side interface L{muntjac.terminal.Paintable}).
    Any client-side changes (typically resulting from user actions) are sent
    back to the server as variable changes (see L{updateVariable()}).

    Entry point classes (widgetsets) define C{onModuleLoad()}.
    """

    # This indicates the whole page is generated by us (not embedded)
    GENERATED_BODY_CLASSNAME = 'v-generated-body'

    _MODIFIED_CLASSNAME = 'v-modified'

    DISABLED_CLASSNAME = 'v-disabled'

    _REQUIRED_CLASSNAME_EXT = '-required'

    _ERROR_CLASSNAME_EXT = '-error'

    VAR_RECORD_SEPARATOR = u'\u001e'

    VAR_FIELD_SEPARATOR = u'\u001f'

    VAR_BURST_SEPARATOR = u'\u001d'

    VAR_ARRAYITEM_SEPARATOR = u'\u001c'

    VAR_ESCAPE_CHARACTER = u'\u001b'

    UIDL_SECURITY_TOKEN_ID = 'Vaadin-Security-Key'

    # @deprecated: use UIDL_SECURITY_TOKEN_ID instead
    UIDL_SECURITY_HEADER = UIDL_SECURITY_TOKEN_ID

    PARAM_UNLOADBURST = 'onunloadburst'

    ATTRIBUTE_DESCRIPTION = 'description'

    ATTRIBUTE_ERROR = 'error'

    MAX_CSS_WAITS = 100

    def __init__(self):
        # will hold the UIDL security key (for XSS protection) once received
        self._uidlSecurityKey = 'init'

        self._resourcesMap = dict()

        self._pendingVariables = list()

        self._idToPaintableDetail = ComponentDetailMap.create()

        self._widgetSet = None

        self._contextMenu = None

        self._loadTimer = None

        self._loadTimer2 = None

        self._loadTimer3 = None

        self._loadElement = None

        self._view = None

        self.applicationRunning = False

        self._activeRequests = 0

        #: Parameters for this application connection loaded from the web-page
        self._configuration = None

        #: List of pending variable change bursts that must be submitted in order
        self._pendingVariableBursts = list()

        #: Timer for automatic refirect to SessionExpiredURL
        self._redirectTimer = None

        #: redirectTimer scheduling interval in seconds
        self._sessionExpirationInterval = None

        self._relativeSizeChanges = list()

        self._componentCaptionSizeChanges = list()

        self._requestStartTime = None

        self._validatingLayouts = False

        self._zeroWidthComponents = None

        self._zeroHeightComponents = None

        self._unregistryBag = set()

        self._cssWaits = 0

        self._layoutTimer = LayoutTimer(self)

        self._windowName = None

        self._view = GWT.create(VView)


    def init(self, widgetSet, cnf):
        VConsole.log('Starting application ' + cnf.getRootPanelId())

        VConsole.log('Vaadin application servlet version: '
                + cnf.getServletVersion())
        VConsole.log('Application version: ' + cnf.getApplicationVersion())

        if not (cnf.getServletVersion() == ApplicationConfiguration.VERSION):
            VConsole.error('Warning: your widget set seems to be built with a different '
                    + 'version than the one used on server. Unexpected '
                    + 'behavior may occur.')

        self._widgetSet = widgetSet
        self._configuration = cnf
        self._windowName = self._configuration.getInitialWindowName()

        componentLocator = ComponentLocator(self)

        appRootPanelName = cnf.getRootPanelId()
        # remove the end (window name) of autogenerated rootpanel id
        appRootPanelName = appRootPanelName.replaceFirst('-\\d+$', '')

        self.initializeTestbenchHooks(componentLocator, appRootPanelName)

        self.initializeClientHooks()

        self._view.init(cnf.getRootPanelId(), self)
        self.showLoadingIndicator()


    def start(self):
        """Starts this application. Don't call this method directly - it's
        called by L{ApplicationConfiguration.startNextApplication}, which
        should be called once this application has started (first response
        received) or failed to start. This ensures that the applications are
        started in order, to avoid session-id problems.
        """
        self.repaintAll()


    def initializeTestbenchHooks(self, componentLocator, TTAppId):
        JS("""
        	var ap = @{{self}};
        	var client = {};
        	client.isActive = function() {
        		return ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::hasActiveRequest()()
        				|| ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::isExecutingDeferredCommands()();
        	}
        	var vi = ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::getVersionInfo()();
        	if (vi) {
        		client.getVersionInfo = function() {
        			return vi;
        		}
        	}

        	client.getElementByPath = function(id) {
        		return @{{componentLocator}}.@com.vaadin.terminal.gwt.client.ComponentLocator::getElementByPath(Ljava/lang/String;)(id);
        	}
        	client.getPathForElement = function(element) {
        		return @{{componentLocator}}.@com.vaadin.terminal.gwt.client.ComponentLocator::getPathForElement(Lcom/google/gwt/user/client/Element;)(element);
        	}

        	if (!$wnd.vaadin.clients) {
        		$wnd.vaadin.clients = {};
        	}

        	$wnd.vaadin.clients[@{{TTAppId}}] = client;
        """)
        pass


    def getVersionInfo(self):
        """Helper for tt initialization"""
        return self._configuration.getVersionInfoJSObject()


    def initializeClientHooks(self):
        """Publishes a JavaScript API for mash-up applications.

          * C{vaadin.forceSync()} sends pending variable changes, in effect
            synchronizing the server and client state. This is done for all
            applications on host page.
          * C{vaadin.postRequestHooks} is a map of functions which gets
            called after each XHR made by vaadin application. Note, that it
            is attaching js functions responsibility to create the variable
            like this::

                if(!vaadin.postRequestHooks) {vaadin.postRequestHooks = new Object();}
                postRequestHooks.myHook = function(appId) {
                         if(appId == "MyAppOfInterest") {
                                 // do the staff you need on xhr activity
                         }
                }

            First parameter passed to these functions is the identifier
            of Muntjac application that made the request.

        TODO: make this multi-app aware
        """
        JS("""
        	var app = @{{self}};
        	var oldSync;
        	if ($wnd.vaadin.forceSync) {
        		oldSync = $wnd.vaadin.forceSync;
        	}
        	$wnd.vaadin.forceSync = function() {
        		if (oldSync) {
        			oldSync();
        		}
        		app.@com.vaadin.terminal.gwt.client.ApplicationConnection::sendPendingVariableChanges()();
        	}
        	var oldForceLayout;
        	if ($wnd.vaadin.forceLayout) {
        		oldForceLayout = $wnd.vaadin.forceLayout;
        	}
        	$wnd.vaadin.forceLayout = function() {
        		if (oldForceLayout) {
        			oldForceLayout();
        		}
        		app.@com.vaadin.terminal.gwt.client.ApplicationConnection::forceLayout()();
        	}
        """)
        pass


    @classmethod
    def runPostRequestHooks(cls, appId):
        """Runs possibly registered client side post request hooks. This is
        expected to be run after each uidl request made by Vaadin application.
        """
        JS("""
        	if ($wnd.vaadin.postRequestHooks) {
        		for ( var hook in $wnd.vaadin.postRequestHooks) {
        			if (typeof ($wnd.vaadin.postRequestHooks[hook]) == "function") {
        				try {
        					$wnd.vaadin.postRequestHooks[hook](@{{appId}});
        				} catch (e) {
        				}
        			}
        		}
        	}
        """)
        pass


    @classmethod
    def getConsole(cls):
        """Get the active Console for writing debug messages. May return
        an actual logging console, or the NullConsole if debugging is not
        turned on.

        @deprecated: Developers should use L{VConsole}
        @return: the active Console
        """
        return VConsole.getImplementation()


    @classmethod
    def isDebugMode(cls):
        """Checks if client side is in debug mode. Practically this is invoked
        by adding ?debug parameter to URI.

        @deprecated: use ApplicationConfiguration isDebugMode instead.
        @return: true if client side is currently been debugged
        """
        return ApplicationConfiguration.isDebugMode()


    def getAppUri(self):
        """Gets the application base URI.

        @return: application base URI
        """
        return self._configuration.getApplicationUri()


    def hasActiveRequest(self):
        """Indicates whether or not there are currently active UIDL requests.
        Used internally to sequence requests properly, seldom needed in
        Widgets.

        @return: true if there are active requests
        """
        return self._activeRequests > 0


    def getRepaintAllParameters(self):
        # collect some client side data that will be sent to server on
        # initial uidl request
        clientHeight = Window.getClientHeight()
        clientWidth = Window.getClientWidth()
        pe = self._view.getElement().getParentElement()
        offsetHeight = pe.getOffsetHeight()
        offsetWidth = pe.getOffsetWidth()
        screenWidth = BrowserInfo.get().getScreenWidth()
        screenHeight = BrowserInfo.get().getScreenHeight()
        tzOffset = BrowserInfo.get().getTimezoneOffset()
        rtzOffset = BrowserInfo.get().getRawTimezoneOffset()
        dstDiff = BrowserInfo.get().getDSTSavings()
        dstInEffect = BrowserInfo.get().isDSTInEffect()
        curDate = BrowserInfo.get().getCurrentDate().getTime()
        widgetsetVersion = ApplicationConfiguration.VERSION

        token = History.getToken()

        # TODO figure out how client and view size could be used better on
        # server. screen size can be accessed via Browser object, but other
        # values currently only via transaction listener.
        parameters = ('repaintAll=1&' + 'sh=' + screenHeight + '&sw='
                + screenWidth + '&cw=' + clientWidth + '&ch=' + clientHeight
                + '&vw=' + offsetWidth + '&vh=' + offsetHeight + '&fr='
                + token + '&tzo=' + tzOffset + '&rtzo=' + rtzOffset + '&dstd='
                + dstDiff + '&dston=' + dstInEffect + '&curdate=' + curDate
                + '&wsver=' + widgetsetVersion
                + ('&td=1' if BrowserInfo.get().isTouchDevice() else ''))
        return parameters


    def repaintAll(self):
        repainAllParameters = self.getRepaintAllParameters()
        self.makeUidlRequest('', repainAllParameters, False)


    def analyzeLayouts(self):
        """Requests an analyze of layouts, to find inconsistencies. Exclusively
        used for debugging during development.
        """
        params = self.getRepaintAllParameters() + '&analyzeLayouts=1'
        self.makeUidlRequest('', params, False)


    def highlightComponent(self, paintable):
        """Sends a request to the server to print details to console that will
        help developer to locate component in the source code.
        """
        params = (self.getRepaintAllParameters() + '&highlightComponent='
                + self.getPid(paintable))
        self.makeUidlRequest('', params, False)


    def makeUidlRequest(self, requestData, extraParams='', forceSync=False):
        """Makes an UIDL request to the server.

        @param requestData:
                   Data that is passed to the server.
        @param extraParams:
                   Parameters that are added as GET parameters to the url.
                   Contains key=value pairs joined by & characters or is empty
                   if no parameters should be added. Should not start with any
                   special character.
        @param forceSync:
                   true if the request should be synchronous, false otherwise
        """
        self.startRequest()
        # Security: double cookie submission pattern
        payload = (self._uidlSecurityKey + self.VAR_BURST_SEPARATOR
                + requestData)
        VConsole.log('Making UIDL Request with params: ' + payload)
        if self._configuration.usePortletURLs():
            uri = self._configuration.getPortletUidlURLBase()
        else:
            uri = self.getAppUri() + 'UIDL'

        if (extraParams is not None) and (len(extraParams) > 0):
            uri = self.addGetParameters(uri, extraParams)

        if (self._windowName is not None) and (len(self._windowName) > 0):
            uri = self.addGetParameters(uri, 'windowName=' + self._windowName)

        self.doUidlRequest(uri, payload, forceSync)


    def doUidlRequest(self, uri, payload, synchronous):
        """Sends an asynchronous or synchronous UIDL request to the server
        using the given URI.

        @param uri:
                   The URI to use for the request. May includes GET parameters
        @param payload:
                   The contents of the request to send
        @param synchronous:
                   true if the request should be synchronous, false otherwise
        """
        if not synchronous:
            requestCallback = \
                    UidlRequestCallback(uri, payload, synchronous, self)

            try:
                self.doAsyncUIDLRequest(uri, payload, requestCallback)
            except RequestException, e:
                VConsole.error(e)
                self.endRequest()
        else:
            # Synchronized call, discarded response (leaving the page)
            syncXHR = SynchronousXHR.create()
            syncXHR.synchronousPost(uri + '&' + self.PARAM_UNLOADBURST + '=1',
                    payload)
            # Although we are in theory leaving the page, the page may still
            # stay open. End request properly here too. See #3289
            self.endRequest()


    def doAsyncUIDLRequest(self, uri, payload, requestCallback):
        """Sends an asynchronous UIDL request to the server using the given URI.

        @param uri:
                   The URI to use for the request. May includes GET parameters
        @param payload:
                   The contents of the request to send
        @param requestCallback:
                   The handler for the response
        @throws RequestException:
                    if the request could not be sent
        """
        rb = RequestBuilder(RequestBuilder.POST, uri)
        # TODO enable timeout
        # rb.setTimeoutMillis(timeoutMillis);
        rb.setHeader('Content-Type', 'text/plain;charset=utf-8')
        rb.setRequestData(payload)
        rb.setCallback(requestCallback)
        rb.send()


    def handleWhenCSSLoaded(self, jsonText, json):
        heightOfLoadElement = DOM.getIntElemAttribute(self._loadElement,
                'offsetHeight')
        if heightOfLoadElement == 0 and self._cssWaits < self.MAX_CSS_WAITS:

            class CssTimer(Timer):

                def __init__(self, jsonText, json, conn):
                    self._jsonText = jsonText
                    self._json = json
                    self._conn = conn

                def run(self):
                    self._conn.handleWhenCSSLoaded(self._jsonText, self._json)

            timer = CssTimer(jsonText, json, self)
            timer.schedule(50)
            VConsole.log('Assuming CSS loading is not complete, '
                    + 'postponing render phase. '
                    + '(.v-loading-indicator height == 0)')
            self._cssWaits += 1
        else:
            self.handleReceivedJSONMessage(datetime(), jsonText, json)
            if self._cssWaits >= self.MAX_CSS_WAITS:
                VConsole.error('CSS files may have not loaded properly.')


    def showCommunicationError(self, details):
        """Shows the communication error notification.

        @param details:
                   Optional details for debugging.
        """
        VConsole.error('Communication error: ' + details)
        self.showError(details,
                self._configuration.getCommunicationErrorCaption(),
                self._configuration.getCommunicationErrorMessage(),
                self._configuration.getCommunicationErrorUrl())


    def showAuthenticationError(self, details):
        """Shows the authentication error notification.

        @param details:
                   Optional details for debugging.
        """
        VConsole.error('Authentication error: ' + details)
        self.showError(details,
                self._configuration.getAuthorizationErrorCaption(),
                self._configuration.getAuthorizationErrorMessage(),
                self._configuration.getAuthorizationErrorUrl())


    def showError(self, details, caption, message, url):
        """Shows the error notification.

        @param details:
                   Optional details for debugging.
        """
        html = StringIO()
        if caption is not None:
            html.write('<h1>')
            html.write(caption)
            html.write('</h1>')
        if message is not None:
            html.write('<p>')
            html.write(message)
            html.write('</p>')
        if len(html) > 0:
            # Add error description
            html.write('<br/><p><I style=\"font-size:0.7em\">')
            html.write(details)
            html.write('</I></p>')
            n = VNotification.createNotification(1000 * 60 * 45)
            n.addEventListener(NotificationRedirect(url, self))
            n.show(html.getvalue(), VNotification.CENTERED_TOP,
                VNotification.STYLE_SYSTEM)
            html.close()
        else:
            self.redirect(url)


    def startRequest(self):
        self._activeRequests += 1
        self._requestStartTime = datetime()
        # show initial throbber
        if self._loadTimer is None:

            class LoadTimer(Timer):

                def __init__(self, conn):
                    self._conn = conn

                def run(self):
                    # IE7 does not properly cancel the event with
                    # loadTimer.cancel() so we have to check that we really
                    # should make it visible
                    if self._conn._loadTimer is not None:
                        self._conn.showLoadingIndicator()

            self._loadTimer = LoadTimer(self)
            # First one kicks in at 300ms
        self._loadTimer.schedule(300)


    def endRequest(self):
        if self.applicationRunning:
            self.checkForPendingVariableBursts()
            self.runPostRequestHooks(self._configuration.getRootPanelId())
        self._activeRequests -= 1

        class EndCommand(Command):

            def __init__(self, conn):
                self._conn = conn

            def execute(self):
                if self._conn._activeRequests == 0:
                    self._conn.hideLoadingIndicator()

        Scheduler.get().scheduleDeferred( EndCommand(self) )


    def checkForPendingVariableBursts(self):
        """This method is called after applying uidl change set to application.

        It will clean current and queued variable change sets. And send next
        change set if it exists.
        """
        self.cleanVariableBurst(self._pendingVariables)
        if len(self._pendingVariableBursts) > 0:
            for burst in self._pendingVariableBursts:
                self.cleanVariableBurst(burst)

            nextBurst = self._pendingVariableBursts[0]
            self._pendingVariableBursts.remove(0)
            self.buildAndSendVariableBurst(nextBurst, False)


    def cleanVariableBurst(self, variableBurst):
        """Cleans given queue of variable changes of such changes that came
        from components that do not exist anymore.
        """
        i = 1
        while i < len(variableBurst):
            Id = variableBurst[i]
            Id = Id[:Id.find(self.VAR_FIELD_SEPARATOR)]
            if Id not in self._idToPaintableDetail and not Id.startswith('DD'):
                # variable owner does not exist anymore
                variableBurst.remove(i - 1)
                variableBurst.remove(i - 1)
                i -= 2
                VConsole.log('Removed variable from removed component: ' + Id)
            i += 2


    def showLoadingIndicator(self):
        # show initial throbber
        if self._loadElement is None:
            self._loadElement = DOM.createDiv()
            DOM.setStyleAttribute(self._loadElement, 'position', 'absolute')
            DOM.appendChild(self._view.getElement(), self._loadElement)
            VConsole.log('inserting load indicator')
        DOM.setElemAttribute(self._loadElement, 'className',
                'v-loading-indicator')
        DOM.setStyleAttribute(self._loadElement, 'display', 'block')

        # Initialize other timers

        class LoadTimer2(Timer):

            def __init__(self, conn):
                self._conn = conn

            def run(self):
                DOM.setElemAttribute(self._conn._loadElement,
                        'className', 'v-loading-indicator-delay')

        self._loadTimer2 = LoadTimer2(self)
        # Second one kicks in at 1500ms from request start
        self._loadTimer2.schedule(1200)

        class LoadTimer3(Timer):

            def __init__(self, conn):
                self._conn = conn

            def run(self):
                DOM.setElemAttribute(self._conn._loadElement,
                        'className', 'v-loading-indicator-wait')

        self._loadTimer3 = LoadTimer3(self)
        # Third one kicks in at 5000ms from request start
        self._loadTimer3.schedule(4700)


    def hideLoadingIndicator(self):
        if self._loadTimer is not None:
            self._loadTimer.cancel()
            if self._loadTimer2 is not None:
                self._loadTimer2.cancel()
                self._loadTimer3.cancel()

            self._loadTimer = None

        if self._loadElement is not None:
            DOM.setStyleAttribute(self._loadElement, 'display', 'none')


    def isExecutingDeferredCommands(self):
        """Checks if deferred commands are (potentially) still being executed
        as a result of an update from the server. Returns true if a deferred
        command might still be executing, false otherwise. This will not work
        correctly if a deferred command is added in another deferred command.

        Used by the native "client.isActive" function.

        @return: true if deferred commands are (potentially) being executed,
                 false otherwise
        """
        s = Scheduler.get()
        if isinstance(s, VSchedulerImpl):
            return s.hasWorkQueued()
        else:
            return False


    def isLoadingIndicatorVisible(self):
        """Determines whether or not the loading indicator is showing.

        @return: true if the loading indicator is visible
        """
        if self._loadElement is None:
            return False
        if self._loadElement.getStyle().getProperty('display') == 'none':
            return False
        return True


    @classmethod
    def parseJSONResponse(cls, jsonText):
        JS("""
        	try {
        		return JSON.parse(@{{jsonText}});
        	} catch (ignored) {
        		return eval('(' + @{{jsonText}} + ')');
        	}
        """)
        pass


    def handleReceivedJSONMessage(self, start, jsonText, json):
        self.handleUIDLMessage(start, jsonText, json)


    def handleUIDLMessage(self, start, jsonText, json):
        # Handle redirect
        if 'redirect' in json:
            url = json.getValueMap('redirect').getString('url')
            VConsole.log('redirecting to ' + url)
            self.redirect(url)
            return

        # Get security key
        if self.UIDL_SECURITY_TOKEN_ID in json:
            self._uidlSecurityKey = json.getString(self.UIDL_SECURITY_TOKEN_ID)

        if 'resources' in json:
            resources = json.getValueMap('resources')
            keyArray = resources.getKeyArray()
            l = len(keyArray)
            for i in range(l):
                key = keyArray.get(i)
                self._resourcesMap[key] = resources.getAsString(key)

        if 'typeMappings' in json:
            tm = json.getValueMap('typeMappings')
            self._configuration.addComponentMappings(tm, self._widgetSet)

        class UidlCommand(Command):

            def __init__(self, jsonText, json, conn):
                self._jsonText = jsonText
                self._json = json
                self._conn = conn

            def execute(self):
                VConsole.dirUIDL(self.json, self._conn._configuration)

                if 'locales' in self.json:
                    # Store locale data
                    valueMapArray = self.json.getJSValueMapArray('locales')
                    LocaleService.addLocales(valueMapArray)

                repaintAll = False
                meta = None
                if 'meta' in self._json:
                    meta = self._json.getValueMap('meta')
                    if 'repaintAll' in meta:
                        repaintAll = True
                        self._conn._view.clear()
                        self._conn._idToPaintableDetail.clear()
                        if 'invalidLayouts' in meta:
                            self._conn._validatingLayouts = True
                            self._conn._zeroWidthComponents = set()
                            self._conn._zeroHeightComponents = set()
                    if 'timedRedirect' in meta:
                        timedRedirect = meta.getValueMap('timedRedirect')

                        class UidlTimer(Timer):

                            def run(self):
                                url = self.timedRedirect.getString('url')
                                self._conn.redirect(url)

                        self._conn._redirectTimer = UidlTimer()
                        self._conn._sessionExpirationInterval = \
                                timedRedirect.getInt('interval')
                if self._conn._redirectTimer is not None:
                    t = 1000 * self._conn._sessionExpirationInterval
                    self._conn._redirectTimer.schedule(t)

                # Process changes
                changes = self.json.getJSValueMapArray('changes')
                updatedWidgets = list()
                self._conn._relativeSizeChanges.clear()
                self._conn._componentCaptionSizeChanges.clear()

                length = len(changes)
                for i in range(length):
                    try:
                        change = changes.get(i)
                        uidl = change.getChildUIDL(0)
                        # TODO optimize
                        paintable = self._conn.getPaintable(uidl.getId())
                        if paintable is not None:
                            paintable.updateFromUIDL(uidl, self._conn)
                            # paintable may have changed during render to
                            # another implementation, use the new one for
                            # updated widgets map
                            updatedWidgets.add(self._conn._idToPaintableDetail.get(uidl.getId()).getComponent())
                        elif uidl.getTag() != self._conn._configuration.getEncodedWindowTag():
                            VConsole.error('Received update for '
                                    + uidl.getTag() + ', but there is no such paintable ('
                                    + uidl.getId() + ') rendered.')
                        else:
                            pid = uidl.getId()
                            if (pid not in self._conn._idToPaintableDetail):
                                self._conn.registerPaintable(pid,
                                        self._conn._view)
                            # VView does not call updateComponent so we
                            # register any event listeners here
                            cd = self._conn._idToPaintableDetail.get(pid)
                            cd.registerEventListenersFromUIDL(uidl)
                            # Finally allow VView to update itself
                            self._conn._view.updateFromUIDL(uidl, self._conn)
                    except BaseException, e:
                        VConsole.error(e)

                if 'dd' in self.json:
                    # response contains data for drag and drop service
                    VDragAndDropManager.get().handleServerResponse(
                            self.json.getValueMap('dd'))

                # Check which widgets' size has been updated
                sizeUpdatedWidgets = set()

                updatedWidgets.addAll(self._conn._relativeSizeChanges)
                sizeUpdatedWidgets.addAll(self._conn._componentCaptionSizeChanges)

                for paintable in updatedWidgets:
                    detail = self._conn._idToPaintableDetail.get(
                            self._conn.getPid(paintable))
                    widget = paintable
                    oldSize = detail.getOffsetSize()
                    newSize = Size(widget.getOffsetWidth(),
                            widget.getOffsetHeight())

                    if (oldSize is None) or (oldSize != newSize):
                        sizeUpdatedWidgets.add(paintable)
                        detail.setOffsetSize(newSize)

                Util.componentSizeUpdated(sizeUpdatedWidgets)

                if meta is not None:
                    if 'appError' in meta:
                        error = meta.getValueMap('appError')
                        html = ''
                        if ('caption' in error
                                and error.getString('caption') is not None):
                            html += ('<h1>' + error.getAsString('caption')
                                    + '</h1>')

                        if ('message' in error
                                and error.getString('message') is not None):
                            html += ('<p>' + error.getAsString('message')
                                    + '</p>')

                        url = None
                        if 'url' in error:
                            url = error.getString('url')

                        if len(html) != 0:
                            # 45 min
                            n = VNotification.createNotification(1000*60*45)
                            n.addEventListener(NotificationRedirect(url, self))
                            n.show(html, VNotification.CENTERED_TOP,
                                   VNotification.STYLE_SYSTEM)
                        else:
                            self._conn.redirect(url)
                        self._conn.applicationRunning = False
                    if self._conn._validatingLayouts:
                        VConsole.printLayoutProblems(meta, self._conn,
                                self._conn._zeroHeightComponents,
                                self._conn._zeroWidthComponents)
                        self._conn._zeroHeightComponents = None
                        self._conn._zeroWidthComponents = None
                        self._conn._validatingLayouts = False

                if repaintAll:
                    # idToPaintableDetail is already cleanded at the start of
                    # the changeset handling, bypass cleanup.
                    self._conn._unregistryBag.clear()
                else:
                    self._conn.purgeUnregistryBag()

                # TODO build profiling for widget impl loading time
                prosessingTime = time() - self._conn.start.getTime()
                VConsole.log(' Processing time was ' + str(prosessingTime)
                    + 'ms for ' + len(self.jsonText) + ' characters of JSON')
                VConsole.log('Referenced paintables: '
                    + len(self._conn._idToPaintableDetail))
                self._conn.endRequest()

        c = UidlCommand(jsonText, json, self)
        ApplicationConfiguration.runWhenWidgetsLoaded(c)


    def sendPendingVariableChangesSync(self):
        """This method assures that all pending variable changes are sent to
        server. Method uses synchronized xmlhttprequest and does not return
        before the changes are sent. No UIDL updates are processed and thus
        UI is left in inconsistent state. This method should be called only
        when closing windows - normally sendPendingVariableChanges() should
        be used.
        """
        # Redirect browser, null reloads current page
        if self.applicationRunning:
            self._pendingVariableBursts.add(self._pendingVariables)
            nextBurst = self._pendingVariableBursts[0]
            self._pendingVariableBursts.remove(0)
            self.buildAndSendVariableBurst(nextBurst, True)


    @classmethod
    def redirect(cls, url):
        JS("""
        	if (@{{url}}) {
        		$wnd.location = @{{url}};
        	} else {
        		$wnd.location.reload(false);
        	}
        """)
        pass


    def registerPaintable(self, pid, paintable):
        componentDetail = ComponentDetail(self, pid, paintable)
        self._idToPaintableDetail.put(pid, componentDetail)
        self.setPid(paintable.getElement(), pid)


    def setPid(self, el, pid):
        JS("""
        	@{{el}}.tkPid = @{{pid}};
        """)
        pass


    def getPid(self, el):
        """Gets the paintableId for a specific paintable (a.k.a Muntjac Widget).

        The paintableId is used in the UIDL to identify a specific widget
        instance, effectively linking the widget with it's server side
        Component.

        @param paintable:
                   the paintable who's id is needed
        @return: the id for the given paintable
        ---
        Gets the paintableId using a DOM element - the element should be the
        main element for a paintable otherwise no id will be found. Use
        L{getPid} instead whenever possible.

        @param el:
                   element of the paintable whose pid is desired
        @return: the pid of the element's paintable, if it's a paintable
        """
        if isinstance(el, Paintable):
            paintable = el
            return self.getPid(paintable.getElement())
        else:
            JS("""
                return el.tkPid;
            """)


    def getElementByPid(self, pid):
        """Gets the main element for the paintable with the given id. The
        reverse of L{getPid}.

        @param pid:
                   the pid of the widget whose element is desired
        @return: the element for the paintable corresponding to the pid
        """
        return self.getPaintable(pid).getElement()


    def unregisterPaintable(self, p):
        """Unregisters the given paintable; always use after removing a
        paintable. This method does not remove the paintable from the DOM,
        but marks the paintable so that ApplicationConnection may clean up
        its references to it. Removing the widget from DOM is component
        containers responsibility.

        @param p: the paintable to remove
        """
        # add to unregistry que
        if p is None:
            VConsole.error('WARN: Trying to unregister null paintable')
            return

        Id = self.getPid(p)
        if Id is None:
            # Uncomment the following to debug unregistring components. No
            # paintables with null id should end here. At least one exception
            # is our VScrollTableRow, that is hacked to fake it self as a
            # Paintable to build support for sizing easier.
            if not isinstance(p, VScrollTableRow):
                VConsole.log("Trying to unregister Paintable not created by Application Connection.");

            if isinstance(p, HasWidgets):
                self.unregisterChildPaintables(p)
        else:
            self._unregistryBag.add(Id)
            if isinstance(p, HasWidgets):
                self.unregisterChildPaintables(p)


    def purgeUnregistryBag(self):
        for id in self._unregistryBag:
            componentDetail = self._idToPaintableDetail.get(id)
            if componentDetail is None:
                # this should never happen, but it does :-( See e.g.
                # com.vaadin.tests.components.accordion.RemoveTabs (with test
                # script)
                VConsole.error('ApplicationConnetion tried to unregister component (id=' + id + ') that is never registered (or already unregistered)')
                continue

            # check if can be cleaned
            component = componentDetail.getComponent()
            if not component.isAttached():
                # clean reference from ac to paintable
                self._idToPaintableDetail.remove(id)

            # else NOP : same component has been reattached to another parent
            # or replaced by another component implementation.
        self._unregistryBag.clear()


    def unregisterChildPaintables(self, container):
        """Unregisters a paintable and all it's child paintables recursively.
        Use when after removing a paintable that contains other paintables.
        Does not unregister the given container itself. Does not actually
        remove the paintable from the DOM.

        @see: unregisterPaintable
        """
        for w in container:
            if isinstance(w, Paintable):
                self.unregisterPaintable(w)
            elif isinstance(w, HasWidgets):
                self.unregisterChildPaintables(w)


    def getPaintable(self, value):
        """Returns Paintable element by its id

        @param id
                   Paintable ID
        ---
        Get either existing or new Paintable for given UIDL.

        If corresponding Paintable has been previously painted, return it.
        Otherwise create and register a new Paintable from UIDL. Caller must
        update the returned Paintable from UIDL after it has been connected to
        parent.

        @param uidl
                   UIDL to create Paintable from.
        @return Either existing or new Paintable corresponding to UIDL.
        ---
        Returns a Paintable element by its root element

        @param element
                   Root element of the paintable
        """
        if isinstance(value, basestring):
            componentDetail = self._idToPaintableDetail.get(value)
            if componentDetail is None:
                return None
            else:
                return componentDetail.getComponent()
        elif isinstance(value, UIDL):
            Id = value.getId()
            w = self.getPaintable(Id)
            if w is not None:
                return w
            else:
                w = self._widgetSet.createWidget(value, self._configuration)
                self.registerPaintable(Id, w)
                return w
        else:
            return self.getPaintable(self.getPid(value))


    def addVariableToQueue(self, paintableId, variableName, encodedValue,
                immediate, typ):
        Id = (paintableId + self.VAR_FIELD_SEPARATOR + variableName
              + self.VAR_FIELD_SEPARATOR + typ)

        i = 1
        while i < len(self._pendingVariables):
            if self._pendingVariables[i] == Id:
                del self._pendingVariables[i - 1]
                del self._pendingVariables[i - 1]
                break
            i += 2

        self._pendingVariables.append(encodedValue)
        self._pendingVariables.append(Id)
        if immediate:
            self.sendPendingVariableChanges()


    def sendPendingVariableChanges(self):
        """This method sends currently queued variable changes to server. It
        is called when immediate variable update must happen.

        To ensure correct order for variable changes (due servers
        multithreading or network), we always wait for active request to be
        handler before sending a new one. If there is an active request, we
        will put varible "burst" to queue that will be purged after current
        request is handled.
        """
        if self.applicationRunning:
            if self.hasActiveRequest():
                # skip empty queues if there are pending bursts to be sent
                if ((len(self._pendingVariables) > 0)
                        or (len(self._pendingVariableBursts) == 0)):
                    burst = self._pendingVariables.clone()
                    self._pendingVariableBursts.add(burst)
                    self._pendingVariables.clear()
            else:
                self.buildAndSendVariableBurst(self._pendingVariables, False)


    def buildAndSendVariableBurst(self, pendingVariables, forceSync):
        """Build the variable burst and send it to server.

        When sync is forced, we also force sending of all pending
        variable-bursts at the same time. This is ok as we can assume that
        DOM will never be updated after this.

        @param pendingVariables:
                   Vector of variable changes to send
        @param forceSync:
                   Should we use synchronous request?
        """
        req = str()
        while len(pendingVariables) > 0:
            if ApplicationConfiguration.isDebugMode():
                Util.logVariableBurst(self, pendingVariables)
            for i in range(len(pendingVariables)):
                if i > 0:
                    if i % 2 == 0:
                        req += self.VAR_RECORD_SEPARATOR
                    else:
                        req += self.VAR_FIELD_SEPARATOR

                req += pendingVariables[i]

            pendingVariables.clear()
            # Append all the busts to this synchronous request
            if forceSync and len(self._pendingVariableBursts) > 0:
                pendingVariables = self._pendingVariableBursts[0]
                del self._pendingVariableBursts[0]
                req += self.VAR_BURST_SEPARATOR

        self.makeUidlRequest(str(req), '', forceSync)


    def updateVariable(self, paintableId, variableName, newValue, immediate):
        """Sends a new value for the given paintables given variable to the
        server.

        The update is actually queued to be sent at a suitable time. If
        immediate is true, the update is sent as soon as possible. If immediate
        is false, the update will be sent along with the next immediate update.

        @param paintableId:
                   the id of the paintable that owns the variable
        @param variableName:
                   the name of the variable
        @param newValue:
                   the new value to be sent
        @param immediate:
                   true if the update is to be sent as soon as possible
        """
        if isinstance(newValue, Paintable):
            pid = self.getPid(newValue) if newValue is not None else None
            self.addVariableToQueue(paintableId, variableName, pid,
                    immediate, 'p')
        elif isinstance(newValue, bool):
            self.addVariableToQueue(paintableId, variableName,
                    'true' if newValue else 'false', immediate, 'b')
        elif isinstance(newValue, dict):
            buf = str()
            for i, (key, value) in enumerate(newValue.iteritems()):
                transportType = self.getTransportType(value)
                buf += transportType
                buf += self.escapeVariableValue(key)
                buf += self.VAR_ARRAYITEM_SEPARATOR

                if transportType == 'p':
                    buf += self.getPid(value)
                else:
                    buf += self.escapeVariableValue(str(value))

                if i < len(newValue) - 1:
                    buf += self.VAR_ARRAYITEM_SEPARATOR

            self.addVariableToQueue(paintableId, variableName, buf,
                    immediate, 'm')
        elif isinstance(newValue, float):
#            self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'f')
            self.addVariableToQueue(paintableId, variableName, str(newValue),
                    immediate, 'd')
        elif isinstance(newValue, int):
            self.addVariableToQueue(paintableId, variableName, str(newValue),
                    immediate, 'i')
        elif isinstance(newValue, long):
            self.addVariableToQueue(paintableId, variableName, str(newValue),
                    immediate, 'l')
        elif hasattr(newValue, '__iter__') and isinstance(newValue[0], basestring):
            values = newValue
            buf = str()
            if values is not None:
                for i in range(len(values)):
                    buf += self.escapeVariableValue(values[i])
                    # there will be an extra separator at the end to differentiate
                    # between an empty array and one containing an empty string
                    # only
                    buf += self.VAR_ARRAYITEM_SEPARATOR

            self.addVariableToQueue(paintableId, variableName, str(buf),
                    immediate, 'c')
        elif isinstance(newValue, basestring):
            self.addVariableToQueue(paintableId, variableName,
                    self.escapeVariableValue(newValue), immediate, 's')
        elif hasattr(newValue, '__iter__'):
            values = newValue
            buf = str()
            if values is not None:
                for i in range(len(values)):
                    if i > 0:
                        buf += self.VAR_ARRAYITEM_SEPARATOR
                    value = values[i]
                    transportType = self.getTransportType(value)
                    # first char tells the type in array
                    buf += transportType
                    if transportType == 'p':
                        buf += self.getPid(value)
                    else:
                        buf += self.escapeVariableValue(str(value))

            self.addVariableToQueue(paintableId, variableName, buf,
                    immediate, 'a')


    def getTransportType(self, value):
        if isinstance(value, basestring):
            return 's'
        elif isinstance(value, Paintable):
            return 'p'
        elif isinstance(value, bool):
            return 'b'
        elif isinstance(value, int):
            return 'i'
#        elif isinstance(value, float):
#            return 'f'
        elif isinstance(value, float):
            return 'd'
        elif isinstance(value, long):
            return 'l'
        elif isinstance(value, Enum):
            return 's'  # transported as string representation
        return 'u'


    def escapeVariableValue(self, value):
        """Encode burst, record, field and array item separator characters in
        a String for transport over the network. This protects from separator
        injection attacks.

        @param value:
                   to encode
        @return: encoded value
        """
        result = str()
        for character in value:
            if character == self.VAR_ESCAPE_CHARACTER:
                pass
            if character == self.VAR_BURST_SEPARATOR:
                pass
            if character == self.VAR_RECORD_SEPARATOR:
                pass
            if character == self.VAR_FIELD_SEPARATOR:
                pass
            if character == self.VAR_ARRAYITEM_SEPARATOR:
                result += self.VAR_ESCAPE_CHARACTER
                # encode as letters for easier reading
                result += chr( ord(character) + 48 )
            else:
                result += character

        return result


    def updateComponent(self, component, uidl, manageCaption):
        """Update generic component features.

        Selecting correct implementation
        --------------------------------

        The implementation of a component depends on many properties, including
        styles, component features, etc. Sometimes the user changes those
        properties after the component has been created. Calling this method in
        the beginning of your updateFromUIDL -method automatically replaces your
        component with more appropriate if the requested implementation changes.

        Caption, icon, error messages and description
        =============================================

        Component can delegate management of caption, icon, error messages and
        description to parent layout. This is optional an should be decided by
        component author

        Component visibility and disabling
        ==================================

        This method will manage component visibility automatically and if
        component is an instanceof FocusWidget, also handle component disabling
        when needed.

        @param component:
                   Widget to be updated, expected to implement an instance of
                   Paintable
        @param uidl:
                   UIDL to be painted
        @param manageCaption:
                   True if you want to delegate caption, icon, description and
                   error message management to parent.

        @return: Returns true iff no further painting is needed by caller
        """
        pid = self.getPid(component.getElement())
        if pid is None:
            VConsole.error('Trying to update an unregistered component: '
                    + Util.getSimpleName(component))
            return True

        componentDetail = self._idToPaintableDetail.get(pid)

        if componentDetail is None:
            VConsole.error('ComponentDetail not found for '
                    + Util.getSimpleName(component) + ' with PID '
                    + pid + '. This should not happen.')
            return True

        # If the server request that a cached instance should be used, do
        # nothing
        if uidl.getBooleanAttribute('cached'):
            return True

        # register the listened events by the server-side to the event-handler
        # of the component
        componentDetail.registerEventListenersFromUIDL(uidl)

        # Visibility
        visible = not uidl.getBooleanAttribute('invisible')
        wasVisible = component.isVisible()
        component.setVisible(visible)
        if wasVisible != visible:
            # Changed invisibile <-> visible
            if wasVisible and manageCaption:
                # Must hide caption when component is hidden
                parent = Util.getLayout(component)
                if parent is not None:
                    parent.updateCaption(component, uidl)

        if self._configuration.useDebugIdInDOM() and uidl.getId().startswith('PID_S'):
            DOM.setElemAttribute(component.getElement(), 'id',
                    uidl.getId()[5:])

        if not visible:
            # component is invisible, delete old size to notify parent, if
            # later make visible
            componentDetail.setOffsetSize(None)
            return True

        # Switch to correct implementation if needed
        if not self._widgetSet.isCorrectImplementation(component, uidl,
                self._configuration):
            w = self._widgetSet.createWidget(uidl, self._configuration)
            # deferred binding check
            # TODO: change isCorrectImplementation to use
            # stored detected class, making this innecessary
            if w.__class__ != component.__class__:
                parent = Util.getLayout(component)
                if parent is not None:
                    parent.replaceChildComponent(component, w)
                    self.unregisterPaintable(component)
                    self.registerPaintable(uidl.getId(), w)
                    w.updateFromUIDL(uidl, self)
                    return True

        enabled = not uidl.getBooleanAttribute('disabled')
        if uidl.hasAttribute('tabindex') and isinstance(component, Focusable):
            component.setTabIndex(uidl.getIntAttribute('tabindex'))

        # Disabled state may affect (override) tabindex so the order must be
        # first setting tabindex, then enabled state.
        if isinstance(component, FocusWidget):
            fw = component
            fw.setEnabled(enabled)

        styleBuf = str()
        primaryName = component.getStylePrimaryName()
        styleBuf += primaryName

        # first disabling and read-only status
        if not enabled:
            styleBuf += ' '
            styleBuf += self.DISABLED_CLASSNAME

        if uidl.getBooleanAttribute('readonly'):
            styleBuf += ' '
            styleBuf += 'v-readonly'

        # add additional styles as css classes, prefixed with component
        # default stylename
        if uidl.hasAttribute('style'):
            styles = uidl.getStringAttribute('style').split(' ')
            for i in range(len(styles)):
                styleBuf += ' '
                styleBuf += primaryName
                styleBuf += '-'
                styleBuf += styles[i]
                styleBuf += ' '
                styleBuf += styles[i]

        # add modified classname to Fields
        if uidl.hasAttribute('modified') and isinstance(component, Field):
            styleBuf += ' '
            styleBuf += self._MODIFIED_CLASSNAME

        tooltipInfo = componentDetail.getTooltipInfo(None)
        # Update tooltip
        if uidl.hasAttribute(self.ATTRIBUTE_DESCRIPTION):
            tooltipInfo.setTitle(
                    uidl.getStringAttribute(self.ATTRIBUTE_DESCRIPTION))
        else:
            tooltipInfo.setTitle(None)

        # add error classname to components w/ error
        if uidl.hasAttribute(self.ATTRIBUTE_ERROR):
            tooltipInfo.setErrorUidl(uidl.getErrors())
            styleBuf += ' '
            styleBuf += primaryName
            styleBuf += self._ERROR_CLASSNAME_EXT
        else:
            tooltipInfo.setErrorUidl(None)

        # add required style to required components
        if uidl.hasAttribute('required'):
            styleBuf += ' '
            styleBuf += primaryName
            styleBuf += self._REQUIRED_CLASSNAME_EXT

        # Styles + disabled & readonly
        component.setStyleName(styleBuf)

        # Set captions
        if manageCaption:
            parent = Util.getLayout(component)
            if parent is not None:
                parent.updateCaption(component, uidl)

        # updateComponentSize need to be after caption update so caption can be
        # taken into account

        self.updateComponentSize(componentDetail, uidl)

        return False


    def updateComponentSize(self, cd, uidl):
        w = uidl.getStringAttribute('width') if uidl.hasAttribute('width') else ''

        h = uidl.getStringAttribute('height') if uidl.hasAttribute('height') else ''

        relativeWidth = Util.parseRelativeSize(w)
        relativeHeight = Util.parseRelativeSize(h)

        # First update maps so they are correct in the setHeight/setWidth calls
        if (relativeHeight >= 0.0) or (relativeWidth >= 0.0):
            # One or both is relative
            relativeSize = FloatSize(relativeWidth, relativeHeight)
            if cd.getRelativeSize() is None and cd.getOffsetSize() is not None:
                # The component has changed from absolute size to relative size
                self._relativeSizeChanges.append(cd.getComponent())
            cd.setRelativeSize(relativeSize)
        elif relativeHeight < 0.0 and relativeWidth < 0.0:
            if cd.getRelativeSize() is not None:
                # The component has changed from relative size to absolute size
                self._relativeSizeChanges.add(cd.getComponent())
            cd.setRelativeSize(None)

        component = cd.getComponent()
        # Set absolute sizes
        if relativeHeight < 0.0:
            component.setHeight(h)

        if relativeWidth < 0.0:
            component.setWidth(w)

        # Set relative sizes
        if (relativeHeight >= 0.0) or (relativeWidth >= 0.0):
            # One or both is relative
            self.handleComponentRelativeSize(cd)


    # Traverses recursively child widgets until ContainerResizedListener
    # child widget is found. They will delegate it further if needed.
    _runningLayout = False

    def runDescendentsLayout(self, container):
        """Causes a re-calculation/re-layout of all paintables in a container.
        """
        if self._runningLayout:
            return

        self._runningLayout = True
        self.internalRunDescendentsLayout(container)
        self._runningLayout = False


    def forceLayout(self):
        """This will cause re-layouting of all components. Mainly used for
        development. Published to JavaScript.
        """
        _set = set()
        for cd in self._idToPaintableDetail.values():
            _set.add(cd.getComponent())
        Util.componentSizeUpdated(_set)


    def internalRunDescendentsLayout(self, container):
        # getConsole().log(
        # "runDescendentsLayout(" + Util.getSimpleName(container) + ")")
        childWidgets = container
        for child in childWidgets:
            if isinstance(child, Paintable):
                if self.handleComponentRelativeSize(child):
                    # Only need to propagate event if "child" has a relative
                    # size
                    if isinstance(child, ContainerResizedListener):
                        child.iLayout()
                    if isinstance(child, HasWidgets):
                        childContainer = child
                        self.internalRunDescendentsLayout(childContainer)
            elif isinstance(child, HasWidgets):
                # propagate over non Paintable HasWidgets
                self.internalRunDescendentsLayout(child)


    def handleComponentRelativeSize(self, child):
        """Converts relative sizes into pixel sizes.

        @return: true if the child has a relative size
        """
        if isinstance(child, ComponentDetail):
            cd, = child
            if cd is None:
                return False
            debugSizes = False
            relativeSize = cd.getRelativeSize()
            if relativeSize is None:
                return False
            widget = cd.getComponent()
            horizontalScrollBar = False
            verticalScrollBar = False
            parent = Util.getLayout(widget)
            # Parent-less components (like sub-windows) are relative to browser
            # window.
            if parent is None:
                renderSpace = RenderSpace(Window.getClientWidth(),
                        Window.getClientHeight())
            else:
                renderSpace = parent.getAllocatedSpace(widget)
            if relativeSize.getHeight() >= 0:
                if renderSpace is not None:
                    if renderSpace.getScrollbarSize() > 0:
                        if relativeSize.getWidth() > 100:
                            horizontalScrollBar = True
                        elif (relativeSize.getWidth() < 0
                                and renderSpace.getWidth() > 0):
                            offsetWidth = widget.getOffsetWidth()
                            width = renderSpace.getWidth()
                            if offsetWidth > width:
                                horizontalScrollBar = True
                    height = renderSpace.getHeight()
                    if horizontalScrollBar:
                        height -= renderSpace.getScrollbarSize()
                    if self._validatingLayouts and height <= 0:
                        self._zeroHeightComponents.add(cd.getComponent())
                    height = (height * relativeSize.getHeight()) / 100.0
                    if height < 0:
                        height = 0
                    if debugSizes:
                        VConsole.log('Widget ' + Util.getSimpleName(widget)
                                + '/' + self.getPid(widget.getElement())
                                + ' relative height '
                                + relativeSize.getHeight() + '% of '
                                + renderSpace.getHeight() + 'px (reported by '
                                + Util.getSimpleName(parent) + '/'
                                + ('?' if parent is None else parent.hashCode())
                                + ') : ' + height + 'px')
                    widget.setHeight(height + 'px')
                else:
                    widget.setHeight(relativeSize.getHeight() + '%')
                    VConsole.error(Util.getLayout(widget).__class__.__name__
                            + ' did not produce allocatedSpace for '
                            + widget.__class__.__name__)
            if relativeSize.getWidth() >= 0:
                if renderSpace is not None:
                    width = renderSpace.getWidth()
                    if renderSpace.getScrollbarSize() > 0:
                        if relativeSize.getHeight() > 100:
                            verticalScrollBar = True
                        elif (relativeSize.getHeight() < 0
                              and renderSpace.getHeight() > 0
                              and widget.getOffsetHeight() > renderSpace.getHeight()):
                            verticalScrollBar = True
                    if verticalScrollBar:
                        width -= renderSpace.getScrollbarSize()
                    if self._validatingLayouts and width <= 0:
                        self._zeroWidthComponents.add(cd.getComponent())
                    width = (width * relativeSize.getWidth()) / 100.0
                    if width < 0:
                        width = 0
                    if debugSizes:
                        VConsole.log('Widget ' + Util.getSimpleName(widget)
                                + '/' + self.getPid(widget.getElement())
                                + ' relative width ' + relativeSize.getWidth()
                                + '% of ' + renderSpace.getWidth()
                                + 'px (reported by '
                                + Util.getSimpleName(parent) + '/'
                                + ('?' if parent is None else self.getPid(parent))
                                + ') : ' + width + 'px')
                    widget.setWidth(width + 'px')
                else:
                    widget.setWidth(relativeSize.getWidth() + '%')
                    VConsole.error(Util.getLayout(widget).__class__.__name__
                            + ' did not produce allocatedSpace for '
                            + widget.__class__.__name__)
            return True
        else:
            pid = self.getPid(child.getElement())
            return self.handleComponentRelativeSize(
                    self._idToPaintableDetail.get(pid))


    def getRelativeSize(self, widget):
        """Gets the specified Paintables relative size (percent).

        @param widget:
                   the paintable whose size is needed
        @return:
                   the the size if the paintable is relatively sized,
                   -1 otherwise
        """
        pid = self.getPid(widget.getElement())
        return self._idToPaintableDetail.get(pid).getRelativeSize()


    def getResource(self, name):
        """Gets a recource that has been pre-loaded via UIDL, such as custom
        layouts.

        @param name:
                   identifier of the resource to get
        @return: the resource
        """
        return self._resourcesMap.get(name)


    def getContextMenu(self):
        """Singleton method to get instance of app's context menu.

        @return: VContextMenu object
        """
        if self._contextMenu is None:
            self._contextMenu = VContextMenu()
            DOM.setElemAttribute(self._contextMenu.getElement(),
                    'id', 'PID_VAADIN_CM')
        return self._contextMenu


    def translateVaadinUri(self, uidlUri):
        """Translates custom protocols in UIDL URI's to be recognizable by
        browser. All uri's from UIDL should be routed via this method before
        giving them to browser due URI's in UIDL may contain custom protocols
        like theme://.

        @param uidlUri:
                   Muntjac URI from uidl
        @return: translated URI ready for browser
        """
        if uidlUri is None:
            return None

        if uidlUri.startswith('theme://'):
            themeUri = self._configuration.getThemeUri()
            if themeUri is None:
                VConsole.error('Theme not set: ThemeResource will not be found. ('
                        + uidlUri + ')')
            uidlUri = themeUri + (uidlUri[7:])

        if uidlUri.startswith('app://'):
            uidlUri = self.getAppUri() + (uidlUri[6:])

        return uidlUri


    def getThemeUri(self):
        """Gets the URI for the current theme. Can be used to reference theme
        resources.

        @return: URI to the current theme
        """
        return self._configuration.getThemeUri()


    # Extended title handling

    def getTooltipTitleInfo(self, titleOwner, key):
        """Data showed in tooltips are stored centrilized as it may be needed
        in varios place: caption, layouts, and in owner components themselves.

        Updating TooltipInfo is done in updateComponent method.
        """
        if None is titleOwner:
            return None
        cd = self._idToPaintableDetail.get(self.getPid(titleOwner))
        if None is not cd:
            return cd.getTooltipInfo(key)
        else:
            return None


    def handleTooltipEvent(self, event, owner, key=None):
        """Component may want to delegate Tooltip handling to client. Layouts
        add Tooltip (description, errors) to caption, but some components may
        want them to appear one other elements too.

        Events wanted by this handler are same as in Tooltip.TOOLTIP_EVENTS

        @param event:
        @param owner:
        @param key:
                   the key for tooltip if this is "additional" tooltip, null
                   for components "main tooltip"
        """
        self._tooltip.handleTooltipEvent(event, owner, key)


    def addPngFix(self, el):
        """Adds PNG-fix conditionally (only for IE6) to the specified IMG
        -element.

        @param el:
                   the IMG element to fix
        """
        # Helper to run layout functions triggered by child components with a
        # decent interval.
        b = BrowserInfo.get()
        if b.isIE6():
            Util.addPngFix(el)


    def requestLayoutPhase(self):
        """Components can call this function to run all layout functions. This is
        usually done, when component knows that its size has changed.
        """
        self._layoutTimer.schedule(500)


    def setWindowName(self, newName):
        """Reset the name of the current browser-window. This should reflect the
        window-name used in the server, but might be different from the
        window-object target-name on client.

        @param stringAttribute
                   New name for the window.
        """
        self._windowName = newName


    def getWindowName(self):
        return self._windowName


    def getUidlSecurityKey(self):
        return self._uidlSecurityKey


    def captionSizeUpdated(self, component):
        """Use to notify that the given component's caption has changed;
        layouts may have to be recalculated.

        @param component:
                   the Paintable whose caption has changed
        """
        self._componentCaptionSizeChanges.add(component)


    def getView(self):
        """Gets the main view, a.k.a top-level window.

        @return: the main view
        """
        return self._view


    def registerTooltip(self, paintable, key, tooltip):
        """If component has several tooltips in addition to the one provided by
        L{muntjac.ui.AbstractComponent}, component can register them with
        this method.

        Component must also pipe events to L{handleTooltipEvent} method.

        This method can also be used to deregister tooltips by using null as
        tooltip

        @param paintable:
                   Paintable "owning" this tooltip
        @param key:
                   key assosiated with given tooltip. Can be any object. For
                   example a related dom element. Same key must be given for
                   L{handleTooltipEvent} method.
        @param tooltip:
                   the TooltipInfo object containing details shown in tooltip,
                   null if deregistering tooltip
        """
        componentDetail = self._idToPaintableDetail.get(self.getPid(paintable))
        componentDetail.putAdditionalTooltip(key, tooltip)


    def getConfiguration(self):
        """Gets the L{ApplicationConfiguration} for the current application.

        @see: ApplicationConfiguration
        @return: the configuration for this application
        """
        return self._configuration


    def hasEventListeners(self, paintable, eventIdentifier):
        """Checks if there is a registered server side listener for the event.
        The list of events which has server side listeners is updated
        automatically before the component is updated so the value is correct
        if called from updatedFromUIDL.

        @param eventIdentifier:
                   The identifier for the event
        @return: true if at least one listener has been registered on server
                 side for the event identified by eventIdentifier.
        """
        pid = self.getPid(paintable)
        return self._idToPaintableDetail.get(
                pid).hasEventListeners(eventIdentifier)


    @classmethod
    def addGetParameters(cls, uri, extraParams):
        """Adds the get parameters to the uri and returns the new uri that
        contains the parameters.

        @param uri:
                   The uri to which the parameters should be added.
        @param extraParams:
                   One or more parameters in the format "a=b" or "c=d&e=f". An
                   empty string is allowed but will not modify the url.
        @return: The modified URI with the get parameters in extraParams added.
        """
        if (extraParams is None) or (len(extraParams) == 0):
            return uri

        # RFC 3986: The query component is indicated by the first question
        # mark ("?") character and terminated by a number sign ("#") character
        # or by the end of the URI.
        fragment = None
        hashPosition = uri.find('#')
        if hashPosition != -1:
            # Fragment including "#"
            fragment = uri[hashPosition:]
            # The full uri before the fragment
            uri = uri[:hashPosition]

        if uri.contains('?'):
            uri += '&'
        else:
            uri += '?'

        uri += extraParams
        if fragment is not None:
            uri += fragment

        return uri


class UidlRequestCallback(RequestCallback):

    def __init__(self, uri, payload, synchronous, connection):
        super(UidlRequestCallback, self).__init__()
        self._uri = uri
        self._payload = payload
        self._synchronous = synchronous
        self._conn = connection


    def onError(self, request, exception):
        self._conn.showCommunicationError(exception.getMessage())
        self._conn.endRequest()
        if not self._conn.applicationRunning:
            # start failed, let's try to start the next app
            ApplicationConfiguration.startNextApplication()


    def onResponseReceived(self, request, response):
        VConsole.log('Server visit took '
            + str(time() - self._conn._requestStartTime.getTime())
            + 'ms')

        statusCode = response.getStatusCode()

        if statusCode == 0:
            self._conn.showCommunicationError('Invalid status code 0 (server down?)')
            self._conn.endRequest()
            return
        elif statusCode == 401:
            self._conn.showAuthenticationError('')
            self._conn.endRequest()
            return
        elif statusCode == 503:
            delay = int(response.getHeader('Retry-After'))
            VConsole.log('503, retrying in ' + delay + 'msec')

            class UidlTimer(Timer):

                def __init__(self, uri, payload, synchronous, connection):
                    super(UidlTimer, self).__init__()
                    self._uri = uri
                    self._payload = payload
                    self._synchronous = synchronous
                    self._conn = connection

                def run(self):
                    self._conn._activeRequests -= 1
                    self._conn.doUidlRequest(self._uri, self._payload,
                            self._synchronous)

            timer = UidlTimer(self._uri, self._payload, self._synchronous,
                    self._conn)
            timer.schedule(delay)
            return

        if statusCode / 100 == 4:
            # Handle all 4xx errors the same way as (they are
            # all permanent errors)
            self._conn.showCommunicationError('UIDL could not be read from '
                'server. Check servlets mappings. Error code: ' + statusCode)
            self._conn.endRequest()
            return

        start = datetime()
        # for(;;);[realjson]
        jsonText = response.getText()[9:len(response.getText()) - 1]
        try:
            json = self._conn.parseJSONResponse(jsonText)
        except Exception, e:
            self._conn.endRequest()
            self._conn.showCommunicationError(e.getMessage()
                    + ' - Original JSON-text:' + jsonText)
            return

        VConsole.log('JSON parsing took ' + (time() - start.getTime()) + 'ms')

        if self._conn.applicationRunning:
            self._conn.handleReceivedJSONMessage(start, jsonText, json)
        else:
            self._conn.applicationRunning = True
            self._conn.handleWhenCSSLoaded(jsonText, json)
            ApplicationConfiguration.startNextApplication()


class NotificationRedirect(VNotification.EventListener):
    """Listens for Notification hide event, and redirects. Used for system
    messages, such as session expired.
    """

    def __init__(self, url, conn):
        self._url = url
        self._conn = conn

    def notificationHidden(self, event):
        self._conn.redirect(self._url)


class LayoutTimer(Timer):

    def __init__(self, conn):
        self._isPending = False
        self._conn = conn

    def schedule(self, delayMillis):
        if not self._isPending:
            super(LayoutTimer, self).schedule(delayMillis)
            self._isPending = True

    def run(self):
        VConsole.log('Running re-layout of '
                + self._conn._view.__class__.__name__)
        self._conn.runDescendentsLayout(self._conn._view)
        self._isPending = False
