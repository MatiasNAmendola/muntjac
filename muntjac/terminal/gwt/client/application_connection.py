# Copyright (C) 2011 Vaadin Ltd.
# Copyright (C) 2011 Richard Lincoln
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Note: This is a modified file from Vaadin. For further information on
#       Vaadin please visit http://www.vaadin.com.

from __pyjamas__ import JS

from datetime import time, datetime

from StringIO import StringIO

import pygwt as GWT

from pyjamas import Window, History, DOM
from pyjamas.Timer import Timer

from muntjac.terminal.gwt.client.paintable import Paintable
from muntjac.terminal.gwt.client.v_tooltip import VTooltip
from muntjac.terminal.gwt.client.v_scheduler_impl import VSchedulerImpl, VSchedulerImpl
from muntjac.terminal.gwt.client.ui.v_context_menu import VContextMenu
from muntjac.terminal.gwt.client.container_resized_listener import ContainerResizedListener
from muntjac.terminal.gwt.client.util import Util
from muntjac.terminal.gwt.client.v_console import VConsole
from muntjac.terminal.gwt.client.ui.v_view import VView
from muntjac.terminal.gwt.client.application_configuration import ApplicationConfiguration
from muntjac.terminal.gwt.client.render_space import RenderSpace
from muntjac.terminal.gwt.client.ui.v_notification import VNotification, VNotification
from muntjac.terminal.gwt.client.locale_service import LocaleService
from muntjac.terminal.gwt.client.ui.field import Field
from muntjac.terminal.gwt.client.render_information import RenderInformation, FloatSize, Size
from muntjac.terminal.gwt.client.uidl import UIDL
from muntjac.terminal.gwt.client.component_locator import ComponentLocator
from muntjac.terminal.gwt.client.component_detail import ComponentDetail
from muntjac.terminal.gwt.client.component_detail_map import ComponentDetailMap
from muntjac.terminal.gwt.client.synchronous_xhr import SynchronousXHR
from muntjac.terminal.gwt.client.browser_info import BrowserInfo
from muntjac.terminal.gwt.client.ui.dd.v_drag_and_drop_manager import VDragAndDropManager
from muntjac.terminal.gwt.client.focusable import Focusable

# from com.google.gwt.core.client.GWT import (GWT,)
# from com.google.gwt.core.client.JavaScriptObject import (JavaScriptObject,)
# from com.google.gwt.core.client.JsArray import (JsArray,)
# from com.google.gwt.core.client.JsArrayString import (JsArrayString,)
# from com.google.gwt.core.client.Scheduler import (Scheduler,)
# from com.google.gwt.http.client.Request import (Request,)
# from com.google.gwt.http.client.RequestBuilder import (RequestBuilder,)
# from com.google.gwt.http.client.RequestCallback import (RequestCallback,)
# from com.google.gwt.http.client.RequestException import (RequestException,)
# from com.google.gwt.http.client.Response import (Response,)
# from com.google.gwt.user.client.Command import (Command,)
# from com.google.gwt.user.client.DOM import (DOM,)
# from com.google.gwt.user.client.Element import (Element,)
# from com.google.gwt.user.client.Event import (Event,)
# from com.google.gwt.user.client.History import (History,)
# from com.google.gwt.user.client.Timer import (Timer,)
# from com.google.gwt.user.client.Window import (Window,)
# from com.google.gwt.user.client.ui.FocusWidget import (FocusWidget,)
# from com.google.gwt.user.client.ui.Focusable import (Focusable,)
# from com.google.gwt.user.client.ui.HasWidgets import (HasWidgets,)
# from com.google.gwt.user.client.ui.Widget import (Widget,)
# from java.util.ArrayList import (ArrayList,)
# from java.util.Date import (Date,)
# from java.util.HashMap import (HashMap,)
# from java.util.HashSet import (HashSet,)
# from java.util.Iterator import (Iterator,)
# from java.util.Map import (Map,)
# from java.util.Set import (Set,)


class ApplicationConnection(object):
    """This is the client side communication "engine", managing client-server
    communication with its server side counterpart
    L{AbstractCommunicationManager}.

    Client-side widgets receive updates from the corresponding server-side
    components as calls to L{Paintable.updateFromUIDL} (not to be
    confused with the server side interface L{muntjac.terminal.Paintable}).
    Any client-side changes (typically resulting from user actions) are sent
    back to the server as variable changes (see L{updateVariable()}).

    Entry point classes (widgetsets) define C{onModuleLoad()}.
    """

    # This indicates the whole page is generated by us (not embedded)
    GENERATED_BODY_CLASSNAME = 'v-generated-body'

    _MODIFIED_CLASSNAME = 'v-modified'

    DISABLED_CLASSNAME = 'v-disabled'

    _REQUIRED_CLASSNAME_EXT = '-required'

    _ERROR_CLASSNAME_EXT = '-error'

    VAR_RECORD_SEPARATOR = u'\u001e'

    VAR_FIELD_SEPARATOR = u'\u001f'

    VAR_BURST_SEPARATOR = u'\u001d'

    VAR_ARRAYITEM_SEPARATOR = u'\u001c'

    VAR_ESCAPE_CHARACTER = u'\u001b'

    UIDL_SECURITY_TOKEN_ID = 'Vaadin-Security-Key'

    # @deprecated: use UIDL_SECURITY_TOKEN_ID instead
    UIDL_SECURITY_HEADER = UIDL_SECURITY_TOKEN_ID

    PARAM_UNLOADBURST = 'onunloadburst'

    ATTRIBUTE_DESCRIPTION = 'description'

    ATTRIBUTE_ERROR = 'error'

    MAX_CSS_WAITS = 100

    def __init__(self):
        # will hold the UIDL security key (for XSS protection) once received
        self._uidlSecurityKey = 'init'

        self._resourcesMap = dict()

        self._pendingVariables = list()

        self._idToPaintableDetail = ComponentDetailMap.create()

        self._widgetSet = None

        self._contextMenu = None

        self._loadTimer = None

        self._loadTimer2 = None

        self._loadTimer3 = None

        self._loadElement = None

        self._view = None

        self.applicationRunning = False

        self._activeRequests = 0

        #: Parameters for this application connection loaded from the web-page
        self._configuration = None

        #: List of pending variable change bursts that must be submitted in order
        self._pendingVariableBursts = list()

        #: Timer for automatic refirect to SessionExpiredURL
        self._redirectTimer = None

        #: redirectTimer scheduling interval in seconds
        self._sessionExpirationInterval = None

        self._relativeSizeChanges = list()

        self._componentCaptionSizeChanges = list()

        self._requestStartTime = None

        self._validatingLayouts = False

        self._zeroWidthComponents = None

        self._zeroHeightComponents = None

        self._unregistryBag = set()

        self._cssWaits = 0

        self._view = GWT.create(VView)


    def init(self, widgetSet, cnf):
        VConsole.log('Starting application ' + cnf.getRootPanelId())

        VConsole.log('Vaadin application servlet version: '
                + cnf.getServletVersion())
        VConsole.log('Application version: ' + cnf.getApplicationVersion())

        if not (cnf.getServletVersion() == ApplicationConfiguration.VERSION):
            VConsole.error('Warning: your widget set seems to be built with a different '
                    + 'version than the one used on server. Unexpected '
                    + 'behavior may occur.')

        self._widgetSet = widgetSet
        self._configuration = cnf
        self._windowName = self._configuration.getInitialWindowName()

        componentLocator = ComponentLocator(self)

        appRootPanelName = cnf.getRootPanelId()
        # remove the end (window name) of autogenerated rootpanel id
        appRootPanelName = appRootPanelName.replaceFirst('-\\d+$', '')

        self.initializeTestbenchHooks(componentLocator, appRootPanelName)

        self.initializeClientHooks()

        self._view.init(cnf.getRootPanelId(), self)
        self.showLoadingIndicator()


    def start(self):
        """Starts this application. Don't call this method directly - it's
        called by L{ApplicationConfiguration.startNextApplication}, which
        should be called once this application has started (first response
        received) or failed to start. This ensures that the applications are
        started in order, to avoid session-id problems.
        """
        self.repaintAll()


    def initializeTestbenchHooks(self, componentLocator, TTAppId):
        JS("""
        	var ap = @{{self}};
        	var client = {};
        	client.isActive = function() {
        		return ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::hasActiveRequest()()
        				|| ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::isExecutingDeferredCommands()();
        	}
        	var vi = ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::getVersionInfo()();
        	if (vi) {
        		client.getVersionInfo = function() {
        			return vi;
        		}
        	}

        	client.getElementByPath = function(id) {
        		return @{{componentLocator}}.@com.vaadin.terminal.gwt.client.ComponentLocator::getElementByPath(Ljava/lang/String;)(id);
        	}
        	client.getPathForElement = function(element) {
        		return @{{componentLocator}}.@com.vaadin.terminal.gwt.client.ComponentLocator::getPathForElement(Lcom/google/gwt/user/client/Element;)(element);
        	}

        	if (!$wnd.vaadin.clients) {
        		$wnd.vaadin.clients = {};
        	}

        	$wnd.vaadin.clients[@{{TTAppId}}] = client;
        """)
        pass


    def getVersionInfo(self):
        """Helper for tt initialization"""
        return self._configuration.getVersionInfoJSObject()


    def initializeClientHooks(self):
        """Publishes a JavaScript API for mash-up applications.

          * C{vaadin.forceSync()} sends pending variable changes, in effect
            synchronizing the server and client state. This is done for all
            applications on host page.
          * C{vaadin.postRequestHooks} is a map of functions which gets
            called after each XHR made by vaadin application. Note, that it
            is attaching js functions responsibility to create the variable
            like this::

                if(!vaadin.postRequestHooks) {vaadin.postRequestHooks = new Object();}
                postRequestHooks.myHook = function(appId) {
                         if(appId == "MyAppOfInterest") {
                                 // do the staff you need on xhr activity
                         }
                }

            First parameter passed to these functions is the identifier
            of Muntjac application that made the request.

        TODO: make this multi-app aware
        """
        JS("""
        	var app = @{{self}};
        	var oldSync;
        	if ($wnd.vaadin.forceSync) {
        		oldSync = $wnd.vaadin.forceSync;
        	}
        	$wnd.vaadin.forceSync = function() {
        		if (oldSync) {
        			oldSync();
        		}
        		app.@com.vaadin.terminal.gwt.client.ApplicationConnection::sendPendingVariableChanges()();
        	}
        	var oldForceLayout;
        	if ($wnd.vaadin.forceLayout) {
        		oldForceLayout = $wnd.vaadin.forceLayout;
        	}
        	$wnd.vaadin.forceLayout = function() {
        		if (oldForceLayout) {
        			oldForceLayout();
        		}
        		app.@com.vaadin.terminal.gwt.client.ApplicationConnection::forceLayout()();
        	}
        """)
        pass


    @classmethod
    def runPostRequestHooks(cls, appId):
        """Runs possibly registered client side post request hooks. This is
        expected to be run after each uidl request made by Vaadin application.
        """
        JS("""
        	if ($wnd.vaadin.postRequestHooks) {
        		for ( var hook in $wnd.vaadin.postRequestHooks) {
        			if (typeof ($wnd.vaadin.postRequestHooks[hook]) == "function") {
        				try {
        					$wnd.vaadin.postRequestHooks[hook](@{{appId}});
        				} catch (e) {
        				}
        			}
        		}
        	}
        """)
        pass


    @classmethod
    def getConsole(cls):
        """Get the active Console for writing debug messages. May return
        an actual logging console, or the NullConsole if debugging is not
        turned on.

        @deprecated: Developers should use L{VConsole}
        @return: the active Console
        """
        return VConsole.getImplementation()


    @classmethod
    def isDebugMode(cls):
        """Checks if client side is in debug mode. Practically this is invoked
        by adding ?debug parameter to URI.

        @deprecated: use ApplicationConfiguration isDebugMode instead.
        @return: true if client side is currently been debugged
        """
        return ApplicationConfiguration.isDebugMode()


    def getAppUri(self):
        """Gets the application base URI.

        @return: application base URI
        """
        return self._configuration.getApplicationUri()


    def hasActiveRequest(self):
        """Indicates whether or not there are currently active UIDL requests.
        Used internally to sequence requests properly, seldom needed in
        Widgets.

        @return: true if there are active requests
        """
        return self._activeRequests > 0


    def getRepaintAllParameters(self):
        # collect some client side data that will be sent to server on
        # initial uidl request
        clientHeight = Window.getClientHeight()
        clientWidth = Window.getClientWidth()
        pe = self._view.getElement().getParentElement()
        offsetHeight = pe.getOffsetHeight()
        offsetWidth = pe.getOffsetWidth()
        screenWidth = BrowserInfo.get().getScreenWidth()
        screenHeight = BrowserInfo.get().getScreenHeight()
        tzOffset = BrowserInfo.get().getTimezoneOffset()
        rtzOffset = BrowserInfo.get().getRawTimezoneOffset()
        dstDiff = BrowserInfo.get().getDSTSavings()
        dstInEffect = BrowserInfo.get().isDSTInEffect()
        curDate = BrowserInfo.get().getCurrentDate().getTime()
        widgetsetVersion = ApplicationConfiguration.VERSION

        token = History.getToken()

        # TODO figure out how client and view size could be used better on
        # server. screen size can be accessed via Browser object, but other
        # values currently only via transaction listener.
        parameters = ('repaintAll=1&' + 'sh=' + screenHeight + '&sw='
                + screenWidth + '&cw=' + clientWidth + '&ch=' + clientHeight
                + '&vw=' + offsetWidth + '&vh=' + offsetHeight + '&fr='
                + token + '&tzo=' + tzOffset + '&rtzo=' + rtzOffset + '&dstd='
                + dstDiff + '&dston=' + dstInEffect + '&curdate=' + curDate
                + '&wsver=' + widgetsetVersion
                + ('&td=1' if BrowserInfo.get().isTouchDevice() else ''))
        return parameters


    def repaintAll(self):
        repainAllParameters = self.getRepaintAllParameters()
        self.makeUidlRequest('', repainAllParameters, False)


    def analyzeLayouts(self):
        """Requests an analyze of layouts, to find inconsistencies. Exclusively
        used for debugging during development.
        """
        params = self.getRepaintAllParameters() + '&analyzeLayouts=1'
        self.makeUidlRequest('', params, False)


    def highlightComponent(self, paintable):
        """Sends a request to the server to print details to console that will
        help developer to locate component in the source code.
        """
        params = (self.getRepaintAllParameters() + '&highlightComponent='
                + self.getPid(paintable))
        self.makeUidlRequest('', params, False)


    def makeUidlRequest(self, requestData, extraParams='', forceSync=False):
        """Makes an UIDL request to the server.

        @param requestData:
                   Data that is passed to the server.
        @param extraParams:
                   Parameters that are added as GET parameters to the url.
                   Contains key=value pairs joined by & characters or is empty
                   if no parameters should be added. Should not start with any
                   special character.
        @param forceSync:
                   true if the request should be synchronous, false otherwise
        """
        self.startRequest()
        # Security: double cookie submission pattern
        payload = (self._uidlSecurityKey + self.VAR_BURST_SEPARATOR
                + requestData)
        VConsole.log('Making UIDL Request with params: ' + payload)
        if self._configuration.usePortletURLs():
            uri = self._configuration.getPortletUidlURLBase()
        else:
            uri = self.getAppUri() + 'UIDL'

        if (extraParams is not None) and (len(extraParams) > 0):
            uri = self.addGetParameters(uri, extraParams)

        if (self._windowName is not None) and (len(self._windowName) > 0):
            uri = self.addGetParameters(uri, 'windowName=' + self._windowName)

        self.doUidlRequest(uri, payload, forceSync)


    def doUidlRequest(self, uri, payload, synchronous):
        """Sends an asynchronous or synchronous UIDL request to the server
        using the given URI.

        @param uri:
                   The URI to use for the request. May includes GET parameters
        @param payload:
                   The contents of the request to send
        @param synchronous:
                   true if the request should be synchronous, false otherwise
        """
        if not synchronous:
            requestCallback = \
                    UidlRequestCallback(uri, payload, synchronous, self)

            try:
                self.doAsyncUIDLRequest(uri, payload, requestCallback)
            except RequestException, e:
                VConsole.error(e)
                self.endRequest()
        else:
            # Synchronized call, discarded response (leaving the page)
            syncXHR = SynchronousXHR.create()
            syncXHR.synchronousPost(uri + '&' + self.PARAM_UNLOADBURST + '=1',
                    payload)
            # Although we are in theory leaving the page, the page may still
            # stay open. End request properly here too. See #3289
            self.endRequest()


    def doAsyncUIDLRequest(self, uri, payload, requestCallback):
        """Sends an asynchronous UIDL request to the server using the given URI.

        @param uri:
                   The URI to use for the request. May includes GET parameters
        @param payload:
                   The contents of the request to send
        @param requestCallback:
                   The handler for the response
        @throws RequestException:
                    if the request could not be sent
        """
        rb = RequestBuilder(RequestBuilder.POST, uri)
        # TODO enable timeout
        # rb.setTimeoutMillis(timeoutMillis);
        rb.setHeader('Content-Type', 'text/plain;charset=utf-8')
        rb.setRequestData(payload)
        rb.setCallback(requestCallback)
        rb.send()


    def handleWhenCSSLoaded(self, jsonText, json):
        heightOfLoadElement = DOM.getIntElemAttribute(self._loadElement,
                'offsetHeight')
        if heightOfLoadElement == 0 and self._cssWaits < self.MAX_CSS_WAITS:

            class CssTimer(Timer):

                def __init__(self, jsonText, json, conn):
                    self._jsonText = jsonText
                    self._json = json
                    self._conn = conn

                def run(self):
                    self._conn.handleWhenCSSLoaded(self._jsonText, self._json)

            timer = CssTimer(jsonText, json, self)
            timer.schedule(50)
            VConsole.log('Assuming CSS loading is not complete, '
                    + 'postponing render phase. '
                    + '(.v-loading-indicator height == 0)')
            self._cssWaits += 1
        else:
            self.handleReceivedJSONMessage(datetime(), jsonText, json)
            if self._cssWaits >= self.MAX_CSS_WAITS:
                VConsole.error('CSS files may have not loaded properly.')


    def showCommunicationError(self, details):
        """Shows the communication error notification.

        @param details:
                   Optional details for debugging.
        """
        VConsole.error('Communication error: ' + details)
        self.showError(details,
                self._configuration.getCommunicationErrorCaption(),
                self._configuration.getCommunicationErrorMessage(),
                self._configuration.getCommunicationErrorUrl())


    def showAuthenticationError(self, details):
        """Shows the authentication error notification.

        @param details:
                   Optional details for debugging.
        """
        VConsole.error('Authentication error: ' + details)
        self.showError(details,
                self._configuration.getAuthorizationErrorCaption(),
                self._configuration.getAuthorizationErrorMessage(),
                self._configuration.getAuthorizationErrorUrl())


    def showError(self, details, caption, message, url):
        """Shows the error notification.

        @param details:
                   Optional details for debugging.
        """
        html = StringIO()
        if caption is not None:
            html.write('<h1>')
            html.write(caption)
            html.write('</h1>')
        if message is not None:
            html.write('<p>')
            html.write(message)
            html.write('</p>')
        if len(html) > 0:
            # Add error description
            html.write('<br/><p><I style=\"font-size:0.7em\">')
            html.write(details)
            html.write('</I></p>')
            n = VNotification.createNotification(1000 * 60 * 45)
            n.addEventListener(NotificationRedirect(url))
            n.show(html.getvalue(), VNotification.CENTERED_TOP,
                VNotification.STYLE_SYSTEM)
            html.close()
        else:
            self.redirect(url)


    def startRequest(self):
        self._activeRequests += 1
        self._requestStartTime = datetime()
        # show initial throbber
        if self._loadTimer is None:

            class LoadTimer(Timer):

                def __init__(self, conn):
                    self._conn = conn

                def run(self):
                    # IE7 does not properly cancel the event with
                    # loadTimer.cancel() so we have to check that we really
                    # should make it visible
                    if self._conn._loadTimer is not None:
                        self._conn.showLoadingIndicator()

            self._loadTimer = LoadTimer(self)
            # First one kicks in at 300ms
        self._loadTimer.schedule(300)


    def endRequest(self):
        if self.applicationRunning:
            self.checkForPendingVariableBursts()
            self.runPostRequestHooks(self._configuration.getRootPanelId())
        self._activeRequests -= 1

        class EndCommand(Command):

            def __init__(self, conn):
                self._conn = conn

            def execute(self):
                if self._conn._activeRequests == 0:
                    self._conn.hideLoadingIndicator()

        Scheduler.get().scheduleDeferred( EndCommand(self) )


    def checkForPendingVariableBursts(self):
        """This method is called after applying uidl change set to application.

        It will clean current and queued variable change sets. And send next
        change set if it exists.
        """
        self.cleanVariableBurst(self._pendingVariables)
        if len(self._pendingVariableBursts) > 0:
            for burst in self._pendingVariableBursts:
                self.cleanVariableBurst(burst)

            nextBurst = self._pendingVariableBursts[0]
            self._pendingVariableBursts.remove(0)
            self.buildAndSendVariableBurst(nextBurst, False)


    def cleanVariableBurst(self, variableBurst):
        """Cleans given queue of variable changes of such changes that came
        from components that do not exist anymore.
        """
        i = 1
        while i < len(variableBurst):
            Id = variableBurst[i]
            Id = Id[:Id.find(self.VAR_FIELD_SEPARATOR)]
            if Id not in self._idToPaintableDetail and not Id.startswith('DD'):
                # variable owner does not exist anymore
                variableBurst.remove(i - 1)
                variableBurst.remove(i - 1)
                i -= 2
                VConsole.log('Removed variable from removed component: ' + Id)
            i += 2


    def showLoadingIndicator(self):
        # show initial throbber
        if self._loadElement is None:
            self._loadElement = DOM.createDiv()
            DOM.setStyleAttribute(self._loadElement, 'position', 'absolute')
            DOM.appendChild(self._view.getElement(), self._loadElement)
            VConsole.log('inserting load indicator')
        DOM.setElemAttribute(self._loadElement, 'className',
                'v-loading-indicator')
        DOM.setStyleAttribute(self._loadElement, 'display', 'block')

        # Initialize other timers

        class LoadTimer2(Timer):

            def __init__(self, conn):
                self._conn = conn

            def run(self):
                DOM.setElemAttribute(self._conn._loadElement,
                        'className', 'v-loading-indicator-delay')

        self._loadTimer2 = LoadTimer2(self)
        # Second one kicks in at 1500ms from request start
        self._loadTimer2.schedule(1200)

        class LoadTimer3(Timer):

            def __init__(self, conn):
                self._conn = conn

            def run(self):
                DOM.setElemAttribute(self._conn._loadElement,
                        'className', 'v-loading-indicator-wait')

        self._loadTimer3 = LoadTimer3(self)
        # Third one kicks in at 5000ms from request start
        self._loadTimer3.schedule(4700)


    def hideLoadingIndicator(self):
        if self._loadTimer is not None:
            self._loadTimer.cancel()
            if self._loadTimer2 is not None:
                self._loadTimer2.cancel()
                self._loadTimer3.cancel()

            self._loadTimer = None

        if self._loadElement is not None:
            DOM.setStyleAttribute(self._loadElement, 'display', 'none')


    def isExecutingDeferredCommands(self):
        """Checks if deferred commands are (potentially) still being executed
        as a result of an update from the server. Returns true if a deferred
        command might still be executing, false otherwise. This will not work
        correctly if a deferred command is added in another deferred command.

        Used by the native "client.isActive" function.

        @return: true if deferred commands are (potentially) being executed,
                 false otherwise
        """
        s = Scheduler.get()
        if isinstance(s, VSchedulerImpl):
            return s.hasWorkQueued()
        else:
            return False


    def isLoadingIndicatorVisible(self):
        """Determines whether or not the loading indicator is showing.

        @return: true if the loading indicator is visible
        """
        if self._loadElement is None:
            return False
        if self._loadElement.getStyle().getProperty('display') == 'none':
            return False
        return True


    @classmethod
    def parseJSONResponse(cls, jsonText):
        JS("""
        	try {
        		return JSON.parse(@{{jsonText}});
        	} catch (ignored) {
        		return eval('(' + @{{jsonText}} + ')');
        	}
        """)
        pass


    def handleReceivedJSONMessage(self, start, jsonText, json):
        self.handleUIDLMessage(start, jsonText, json)


    def handleUIDLMessage(self, start, jsonText, json):
        # Handle redirect
        if 'redirect' in json:
            url = json.getValueMap('redirect').getString('url')
            VConsole.log('redirecting to ' + url)
            self.redirect(url)
            return

        # Get security key
        if self.UIDL_SECURITY_TOKEN_ID in json:
            self._uidlSecurityKey = json.getString(self.UIDL_SECURITY_TOKEN_ID)

        if 'resources' in json:
            resources = json.getValueMap('resources')
            keyArray = resources.getKeyArray()
            l = len(keyArray)
            for i in range(l):
                key = keyArray.get(i)
                self._resourcesMap[key] = resources.getAsString(key)

        if 'typeMappings' in json:
            tm = json.getValueMap('typeMappings')
            self._configuration.addComponentMappings(tm, self._widgetSet)

        class UidlCommand(Command):

            def __init__(self, jsonText, json, conn):
                self._jsonText = jsonText
                self._json = json
                self._conn = conn

            def execute(self):
                VConsole.dirUIDL(self.json, self._conn._configuration)

                if 'locales' in self.json:
                    # Store locale data
                    valueMapArray = self.json.getJSValueMapArray('locales')
                    LocaleService.addLocales(valueMapArray)

                repaintAll = False
                meta = None
                if 'meta' in self._json:
                    meta = self._json.getValueMap('meta')
                    if 'repaintAll' in meta:
                        repaintAll = True
                        self._conn._view.clear()
                        self._conn._idToPaintableDetail.clear()
                        if 'invalidLayouts' in meta:
                            self._conn._validatingLayouts = True
                            self._conn._zeroWidthComponents = set()
                            self._conn._zeroHeightComponents = set()
                    if 'timedRedirect' in meta:
                        timedRedirect = meta.getValueMap('timedRedirect')

                        class UidlTimer(Timer):

                            def run(self):
                                url = self.timedRedirect.getString('url')
                                self._conn.redirect(url)

                        self._conn._redirectTimer = UidlTimer()
                        self._conn._sessionExpirationInterval = \
                                timedRedirect.getInt('interval')
                if self._conn._redirectTimer is not None:
                    t = 1000 * self._conn._sessionExpirationInterval
                    self._conn._redirectTimer.schedule(t)

                # Process changes
                changes = self.json.getJSValueMapArray('changes')
                updatedWidgets = list()
                self._conn._relativeSizeChanges.clear()
                self._conn._componentCaptionSizeChanges.clear()

                length = len(changes)
                for i in range(length):
                    try:
                        change = changes.get(i)
                        uidl = change.getChildUIDL(0)
                        # TODO optimize
                        paintable = self._conn.getPaintable(uidl.getId())
                        if paintable is not None:
                            paintable.updateFromUIDL(uidl, self._conn)
                            # paintable may have changed during render to
                            # another implementation, use the new one for
                            # updated widgets map
                            updatedWidgets.add(self._conn._idToPaintableDetail.get(uidl.getId()).getComponent())
                        elif uidl.getTag() != self._conn._configuration.getEncodedWindowTag():
                            VConsole.error('Received update for '
                                    + uidl.getTag() + ', but there is no such paintable ('
                                    + uidl.getId() + ') rendered.')
                        else:
                            pid = uidl.getId()
                            if (pid not in self._conn._idToPaintableDetail):
                                self._conn.registerPaintable(pid,
                                        self._conn._view)
                            # VView does not call updateComponent so we
                            # register any event listeners here
                            cd = self._conn._idToPaintableDetail.get(pid)
                            cd.registerEventListenersFromUIDL(uidl)
                            # Finally allow VView to update itself
                            self._conn._view.updateFromUIDL(uidl, self._conn)
                    except BaseException, e:
                        VConsole.error(e)

                if 'dd' in self.json:
                    # response contains data for drag and drop service
                    VDragAndDropManager.get().handleServerResponse(
                            self.json.getValueMap('dd'))

                # Check which widgets' size has been updated
                sizeUpdatedWidgets = set()

                updatedWidgets.addAll(self._conn._relativeSizeChanges)
                sizeUpdatedWidgets.addAll(self._conn._componentCaptionSizeChanges)

                for paintable in updatedWidgets:
                    detail = self._conn._idToPaintableDetail.get(
                            self._conn.getPid(paintable))
                    widget = paintable
                    oldSize = detail.getOffsetSize()
                    newSize = Size(widget.getOffsetWidth(),
                            widget.getOffsetHeight())

                    if (oldSize is None) or (oldSize != newSize):
                        sizeUpdatedWidgets.add(paintable)
                        detail.setOffsetSize(newSize)

                Util.componentSizeUpdated(sizeUpdatedWidgets)

                if meta is not None:
                    if 'appError' in meta:
                        error = meta.getValueMap('appError')
                        html = ''
                        if ('caption' in error
                                and error.getString('caption') is not None):
                            html += ('<h1>' + error.getAsString('caption')
                                    + '</h1>')

                        if ('message' in error
                                and error.getString('message') is not None):
                            html += ('<p>' + error.getAsString('message')
                                    + '</p>')

                        url = None
                        if 'url' in error:
                            url = error.getString('url')

                        if len(html) != 0:
                            # 45 min
                            n = VNotification.createNotification(1000*60*45)
                            n.addEventListener(NotificationRedirect(url))
                            n.show(html, VNotification.CENTERED_TOP,
                                   VNotification.STYLE_SYSTEM)
                        else:
                            self._conn.redirect(url)
                        self._conn.applicationRunning = False
                    if self._conn._validatingLayouts:
                        VConsole.printLayoutProblems(meta, self._conn,
                                self._conn._zeroHeightComponents,
                                self._conn._zeroWidthComponents)
                        self._conn._zeroHeightComponents = None
                        self._conn._zeroWidthComponents = None
                        self._conn._validatingLayouts = False

                if repaintAll:
                    # idToPaintableDetail is already cleanded at the start of
                    # the changeset handling, bypass cleanup.
                    self._conn._unregistryBag.clear()
                else:
                    self._conn.purgeUnregistryBag()

                # TODO build profiling for widget impl loading time
                prosessingTime = time() - self._conn.start.getTime()
                VConsole.log(' Processing time was ' + str(prosessingTime)
                    + 'ms for ' + len(self.jsonText) + ' characters of JSON')
                VConsole.log('Referenced paintables: '
                    + len(self._conn._idToPaintableDetail))
                self._conn.endRequest()

        c = UidlCommand(jsonText, json, self)
        ApplicationConfiguration.runWhenWidgetsLoaded(c)


    def sendPendingVariableChangesSync(self):
        """This method assures that all pending variable changes are sent to
        server. Method uses synchronized xmlhttprequest and does not return
        before the changes are sent. No UIDL updates are processed and thus
        UI is left in inconsistent state. This method should be called only
        when closing windows - normally sendPendingVariableChanges() should
        be used.
        """
        # Redirect browser, null reloads current page
        if self.applicationRunning:
            self._pendingVariableBursts.add(self._pendingVariables)
            nextBurst = self._pendingVariableBursts[0]
            self._pendingVariableBursts.remove(0)
            self.buildAndSendVariableBurst(nextBurst, True)


    @classmethod
    def redirect(cls, url):
        JS("""
        	if (@{{url}}) {
        		$wnd.location = @{{url}};
        	} else {
        		$wnd.location.reload(false);
        	}
        """)
        pass


    def registerPaintable(self, pid, paintable):
        componentDetail = ComponentDetail(self, pid, paintable)
        self._idToPaintableDetail.put(pid, componentDetail)
        self.setPid(paintable.getElement(), pid)


    def setPid(self, el, pid):
        JS("""
        	@{{el}}.tkPid = @{{pid}};
        """)
        pass


    def getPid(self, el):
        """Gets the paintableId for a specific paintable (a.k.a Muntjac Widget).

        The paintableId is used in the UIDL to identify a specific widget
        instance, effectively linking the widget with it's server side
        Component.

        @param paintable:
                   the paintable who's id is needed
        @return: the id for the given paintable
        ---
        Gets the paintableId using a DOM element - the element should be the
        main element for a paintable otherwise no id will be found. Use
        L{getPid} instead whenever possible.

        @param el:
                   element of the paintable whose pid is desired
        @return: the pid of the element's paintable, if it's a paintable
        """
        if isinstance(el, Paintable):
            paintable = el
            return self.getPid(paintable.getElement())
        else:
            JS("""
                return el.tkPid;
            """)


    def getElementByPid(self, pid):
        """Gets the main element for the paintable with the given id. The
        reverse of L{getPid}.

        @param pid:
                   the pid of the widget whose element is desired
        @return: the element for the paintable corresponding to the pid
        """
        return self.getPaintable(pid).getElement()


    def unregisterPaintable(self, p):
        """Unregisters the given paintable; always use after removing a
        paintable. This method does not remove the paintable from the DOM,
        but marks the paintable so that ApplicationConnection may clean up
        its references to it. Removing the widget from DOM is component
        containers responsibility.

        @param p: the paintable to remove
        """
        # add to unregistry que
        if p is None:
            VConsole.error('WARN: Trying to unregister null paintable')
            return

        Id = self.getPid(p)
        if Id is None:
            # Uncomment the following to debug unregistring components. No
            # paintables with null id should end here. At least one exception
            # is our VScrollTableRow, that is hacked to fake it self as a
            # Paintable to build support for sizing easier.
            if not isinstance(p, VScrollTableRow):
                VConsole.log("Trying to unregister Paintable not created by Application Connection.");

            if isinstance(p, HasWidgets):
                self.unregisterChildPaintables(p)
        else:
            self._unregistryBag.add(Id)
            if isinstance(p, HasWidgets):
                self.unregisterChildPaintables(p)


    def purgeUnregistryBag(self):
        for id in self._unregistryBag:
            componentDetail = self._idToPaintableDetail.get(id)
            if componentDetail is None:
                # this should never happen, but it does :-( See e.g.
                # com.vaadin.tests.components.accordion.RemoveTabs (with test
                # script)
                VConsole.error('ApplicationConnetion tried to unregister component (id=' + id + ') that is never registered (or already unregistered)')
                continue

            # check if can be cleaned
            component = componentDetail.getComponent()
            if not component.isAttached():
                # clean reference from ac to paintable
                self._idToPaintableDetail.remove(id)

            # else NOP : same component has been reattached to another parent
            # or replaced by another component implementation.
        self._unregistryBag.clear()


    def unregisterChildPaintables(self, container):
        """Unregisters a paintable and all it's child paintables recursively.
        Use when after removing a paintable that contains other paintables.
        Does not unregister the given container itself. Does not actually
        remove the paintable from the DOM.

        @see: unregisterPaintable
        """
        for w in container:
            if isinstance(w, Paintable):
                self.unregisterPaintable(w)
            elif isinstance(w, HasWidgets):
                self.unregisterChildPaintables(w)


    def getPaintable(self, value):
        """Returns Paintable element by its id

        @param id
                   Paintable ID
        ---
        Get either existing or new Paintable for given UIDL.

        If corresponding Paintable has been previously painted, return it.
        Otherwise create and register a new Paintable from UIDL. Caller must
        update the returned Paintable from UIDL after it has been connected to
        parent.

        @param uidl
                   UIDL to create Paintable from.
        @return Either existing or new Paintable corresponding to UIDL.
        ---
        Returns a Paintable element by its root element

        @param element
                   Root element of the paintable
        """
        if isinstance(value, basestring):
            componentDetail = self._idToPaintableDetail.get(value)
            if componentDetail is None:
                return None
            else:
                return componentDetail.getComponent()
        elif isinstance(value, UIDL):
            Id = value.getId()
            w = self.getPaintable(Id)
            if w is not None:
                return w
            else:
                w = self._widgetSet.createWidget(value, self._configuration)
                self.registerPaintable(Id, w)
                return w
        else:
            return self.getPaintable(self.getPid(value))


    def addVariableToQueue(self, paintableId, variableName, encodedValue,
                immediate, typ):
        Id = (paintableId + self.VAR_FIELD_SEPARATOR + variableName
              + self.VAR_FIELD_SEPARATOR + typ)

        i = 1
        while i < len(self._pendingVariables):
            if self._pendingVariables[i] == Id:
                del self._pendingVariables[i - 1]
                del self._pendingVariables[i - 1]
                break
            i += 2

        self._pendingVariables.append(encodedValue)
        self._pendingVariables.append(Id)
        if immediate:
            self.sendPendingVariableChanges()


    def sendPendingVariableChanges(self):
        """This method sends currently queued variable changes to server. It
        is called when immediate variable update must happen.

        To ensure correct order for variable changes (due servers
        multithreading or network), we always wait for active request to be
        handler before sending a new one. If there is an active request, we
        will put varible "burst" to queue that will be purged after current
        request is handled.
        """
        if self.applicationRunning:
            if self.hasActiveRequest():
                # skip empty queues if there are pending bursts to be sent
                if ((len(self._pendingVariables) > 0)
                        or (len(self._pendingVariableBursts) == 0)):
                    burst = self._pendingVariables.clone()
                    self._pendingVariableBursts.add(burst)
                    self._pendingVariables.clear()
            else:
                self.buildAndSendVariableBurst(self._pendingVariables, False)


    def buildAndSendVariableBurst(self, pendingVariables, forceSync):
        """Build the variable burst and send it to server.

        When sync is forced, we also force sending of all pending
        variable-bursts at the same time. This is ok as we can assume that
        DOM will never be updated after this.

        @param pendingVariables:
                   Vector of variable changes to send
        @param forceSync:
                   Should we use synchronous request?
        """
        req = str()
        while len(pendingVariables) > 0:
            if ApplicationConfiguration.isDebugMode():
                Util.logVariableBurst(self, pendingVariables)
            for i in range(len(pendingVariables)):
                if i > 0:
                    if i % 2 == 0:
                        req += self.VAR_RECORD_SEPARATOR
                    else:
                        req += self.VAR_FIELD_SEPARATOR

                req += pendingVariables[i]

            pendingVariables.clear()
            # Append all the busts to this synchronous request
            if forceSync and len(self._pendingVariableBursts) > 0:
                pendingVariables = self._pendingVariableBursts[0]
                del self._pendingVariableBursts[0]
                req += self.VAR_BURST_SEPARATOR

        self.makeUidlRequest(str(req), '', forceSync)


    def updateVariable(self, *args):
        """Sends a new value for the given paintables given variable to the
        server.

        The update is actually queued to be sent at a suitable time. If
        immediate is true, the update is sent as soon as possible. If immediate
        is false, the update will be sent along with the next immediate update.

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.

        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.

        A null array is sent as an empty array.

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.

        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update. </p>

        A null array is sent as an empty array.


        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        """
        _0 = args
        _1 = len(args)
        if _1 == 4:
            if isinstance(_0[2], Paintable):
                paintableId, variableName, newValue, immediate = _0
                pid = self.getPid(newValue) if newValue is not None else None
                self.addVariableToQueue(paintableId, variableName, pid, immediate, 'p')
            elif isinstance(_0[2], boolean):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, 'true' if newValue else 'false', immediate, 'b')
            elif isinstance(_0[2], dict):
                paintableId, variableName, map, immediate = _0
                buf = str()
                iterator = map.keys()
                while iterator.hasNext():
                    key = iterator.next()
                    value = map.get(key)
                    transportType = self.getTransportType(value)
                    buf.__add__(transportType)
                    buf.__add__(self.escapeVariableValue(key))
                    buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                    if transportType == 'p':
                        buf.__add__(self.getPid(value))
                    else:
                        buf.__add__(self.escapeVariableValue(String.valueOf.valueOf(value)))
                    if iterator.hasNext():
                        buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                self.addVariableToQueue(paintableId, variableName, str(buf), immediate, 'm')
            elif isinstance(_0[2], float):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'f')
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'd')
            elif isinstance(_0[2], int):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'i')
            elif isinstance(_0[2], long):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'l')
            elif isinstance(_0[2], self.Object):
                paintableId, variableName, values, immediate = _0
                buf = str()
                if values is not None:
                    _0 = True
                    i = 0
                    while True:
                        if _0 is True:
                            _0 = False
                        else:
                            i += 1
                        if not (i < values.length):
                            break
                        if i > 0:
                            buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                        value = values[i]
                        transportType = self.getTransportType(value)
                        # first char tells the type in array
                        buf.__add__(transportType)
                        if transportType == 'p':
                            buf.__add__(self.getPid(value))
                        else:
                            buf.__add__(self.escapeVariableValue(String.valueOf.valueOf(value)))
                self.addVariableToQueue(paintableId, variableName, str(buf), immediate, 'a')
            else:
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, self.escapeVariableValue(newValue), immediate, 's')
                paintableId, variableName, values, immediate = _0
                buf = str()
                if values is not None:
                    _0 = True
                    i = 0
                    while True:
                        if _0 is True:
                            _0 = False
                        else:
                            i += 1
                        if not (i < values.length):
                            break
                        buf.__add__(self.escapeVariableValue(values[i]))
                        # there will be an extra separator at the end to differentiate
                        # between an empty array and one containing an empty string
                        # only
                        buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                self.addVariableToQueue(paintableId, variableName, str(buf), immediate, 'c')
        else:
            raise ARGERROR(4, 4)

    def getTransportType(self, value):
        if isinstance(value, str):
            return 's'
        elif isinstance(value, Paintable):
            return 'p'
        elif isinstance(value, bool):
            return 'b'
        elif isinstance(value, int):
            return 'i'
        elif isinstance(value, float):
            return 'f'
        elif isinstance(value, float):
            return 'd'
        elif isinstance(value, long):
            return 'l'
        elif isinstance(value, self.Enum):
            return 's'
            # transported as string representation
        return 'u'

    def escapeVariableValue(self, value):
        """Encode burst, record, field and array item separator characters in a
        String for transport over the network. This protects from separator
        injection attacks.

        @param value
                   to encode
        @return encoded value
        """
        result = self.StringBuilder()
        _0 = True
        i = 0
        while True:
            if _0 is True:
                _0 = False
            else:
                i += 1
            if not (i < len(value)):
                break
            character = value[i]
            _1 = character
            _2 = False
            while True:
                if _1 == self.VAR_ESCAPE_CHARACTER:
                    _2 = True
                if (_2 is True) or (_1 == self.VAR_BURST_SEPARATOR):
                    _2 = True
                if (_2 is True) or (_1 == self.VAR_RECORD_SEPARATOR):
                    _2 = True
                if (_2 is True) or (_1 == self.VAR_FIELD_SEPARATOR):
                    _2 = True
                if (_2 is True) or (_1 == self.VAR_ARRAYITEM_SEPARATOR):
                    _2 = True
                    result.append(self.VAR_ESCAPE_CHARACTER)
                    # encode as letters for easier reading
                    result.append(character + 48)
                    break
                if True:
                    _2 = True
                    result.append(character)
                    break
                break
        return str(result)

    def updateComponent(self, component, uidl, manageCaption):
        """Update generic component features.

        <h2>Selecting correct implementation</h2>

        <p>
        The implementation of a component depends on many properties, including
        styles, component features, etc. Sometimes the user changes those
        properties after the component has been created. Calling this method in
        the beginning of your updateFromUIDL -method automatically replaces your
        component with more appropriate if the requested implementation changes.
        </p>

        <h2>Caption, icon, error messages and description</h2>

        <p>
        Component can delegate management of caption, icon, error messages and
        description to parent layout. This is optional an should be decided by
        component author
        </p>

        <h2>Component visibility and disabling</h2>

        This method will manage component visibility automatically and if
        component is an instanceof FocusWidget, also handle component disabling
        when needed.

        @param component
                   Widget to be updated, expected to implement an instance of
                   Paintable
        @param uidl
                   UIDL to be painted
        @param manageCaption
                   True if you want to delegate caption, icon, description and
                   error message management to parent.

        @return Returns true iff no further painting is needed by caller
        """
        pid = self.getPid(component.getElement())
        if pid is None:
            VConsole.error('Trying to update an unregistered component: ' + Util.getSimpleName(component))
            return True
        componentDetail = self._idToPaintableDetail.get(pid)
        if componentDetail is None:
            VConsole.error('ComponentDetail not found for ' + Util.getSimpleName(component) + ' with PID ' + pid + '. This should not happen.')
            return True
        # If the server request that a cached instance should be used, do
        # nothing
        if uidl.getBooleanAttribute('cached'):
            return True
        # register the listened events by the server-side to the event-handler
        # of the component
        componentDetail.registerEventListenersFromUIDL(uidl)
        # Visibility
        visible = not uidl.getBooleanAttribute('invisible')
        wasVisible = component.isVisible()
        component.setVisible(visible)
        if wasVisible != visible:
            # Changed invisibile <-> visible
            if wasVisible and manageCaption:
                # Must hide caption when component is hidden
                parent = Util.getLayout(component)
                if parent is not None:
                    parent.updateCaption(component, uidl)
        if self._configuration.useDebugIdInDOM() and uidl.getId().startswith('PID_S'):
            DOM.setElementProperty(component.getElement(), 'id', uidl.getId()[5:])
        if not visible:
            # component is invisible, delete old size to notify parent, if
            # later make visible
            componentDetail.setOffsetSize(None)
            return True
        # Switch to correct implementation if needed
        if (
            not self._widgetSet.isCorrectImplementation(component, uidl, self._configuration)
        ):
            w = self._widgetSet.createWidget(uidl, self._configuration)
            # deferred binding check TODO change isCorrectImplementation to use
            # stored detected class, making this innecessary
            if w.getClass() != component.getClass():
                parent = Util.getLayout(component)
                if parent is not None:
                    parent.replaceChildComponent(component, w)
                    self.unregisterPaintable(component)
                    self.registerPaintable(uidl.getId(), w)
                    w.updateFromUIDL(uidl, self)
                    return True
        enabled = not uidl.getBooleanAttribute('disabled')
        if uidl.hasAttribute('tabindex') and isinstance(component, Focusable):
            component.setTabIndex(uidl.getIntAttribute('tabindex'))
        # Disabled state may affect (override) tabindex so the order must be
        # first setting tabindex, then enabled state.

        if isinstance(component, FocusWidget):
            fw = component
            fw.setEnabled(enabled)
        styleBuf = str()
        primaryName = component.getStylePrimaryName()
        styleBuf.__add__(primaryName)
        # first disabling and read-only status
        if not enabled:
            styleBuf.__add__(' ')
            styleBuf.__add__(self.DISABLED_CLASSNAME)
        if uidl.getBooleanAttribute('readonly'):
            styleBuf.__add__(' ')
            styleBuf.__add__('v-readonly')
        # add additional styles as css classes, prefixed with component default
        # stylename
        if uidl.hasAttribute('style'):
            styles = uidl.getStringAttribute('style').split(' ')
            _0 = True
            i = 0
            while True:
                if _0 is True:
                    _0 = False
                else:
                    i += 1
                if not (i < len(styles)):
                    break
                styleBuf.__add__(' ')
                styleBuf.__add__(primaryName)
                styleBuf.__add__('-')
                styleBuf.__add__(styles[i])
                styleBuf.__add__(' ')
                styleBuf.__add__(styles[i])
        # add modified classname to Fields
        if uidl.hasAttribute('modified') and isinstance(component, Field):
            styleBuf.__add__(' ')
            styleBuf.__add__(self._MODIFIED_CLASSNAME)
        tooltipInfo = componentDetail.getTooltipInfo(None)
        # Update tooltip
        if uidl.hasAttribute(self.ATTRIBUTE_DESCRIPTION):
            tooltipInfo.setTitle(uidl.getStringAttribute(self.ATTRIBUTE_DESCRIPTION))
        else:
            tooltipInfo.setTitle(None)
        # add error classname to components w/ error
        if uidl.hasAttribute(self.ATTRIBUTE_ERROR):
            tooltipInfo.setErrorUidl(uidl.getErrors())
            styleBuf.__add__(' ')
            styleBuf.__add__(primaryName)
            styleBuf.__add__(self._ERROR_CLASSNAME_EXT)
        else:
            tooltipInfo.setErrorUidl(None)
        # add required style to required components
        if uidl.hasAttribute('required'):
            styleBuf.__add__(' ')
            styleBuf.__add__(primaryName)
            styleBuf.__add__(self._REQUIRED_CLASSNAME_EXT)
        # Styles + disabled & readonly
        component.setStyleName(str(styleBuf))
        # Set captions
        if manageCaption:
            parent = Util.getLayout(component)
            if parent is not None:
                parent.updateCaption(component, uidl)
        # updateComponentSize need to be after caption update so caption can be
        # taken into account

        self.updateComponentSize(componentDetail, uidl)
        return False

    def updateComponentSize(self, cd, uidl):
        # Traverses recursively child widgets until ContainerResizedListener child
        # widget is found. They will delegate it further if needed.
        #
        # @param container

        w = uidl.getStringAttribute('width') if uidl.hasAttribute('width') else ''
        h = uidl.getStringAttribute('height') if uidl.hasAttribute('height') else ''
        relativeWidth = Util.parseRelativeSize(w)
        relativeHeight = Util.parseRelativeSize(h)
        # First update maps so they are correct in the setHeight/setWidth calls
        if (relativeHeight >= 0.0) or (relativeWidth >= 0.0):
            # One or both is relative
            relativeSize = FloatSize(relativeWidth, relativeHeight)
            if cd.getRelativeSize() is None and cd.getOffsetSize() is not None:
                # The component has changed from absolute size to relative size
                self._relativeSizeChanges.add(cd.getComponent())
            cd.setRelativeSize(relativeSize)
        elif relativeHeight < 0.0 and relativeWidth < 0.0:
            if cd.getRelativeSize() is not None:
                # The component has changed from relative size to absolute size
                self._relativeSizeChanges.add(cd.getComponent())
            cd.setRelativeSize(None)
        component = cd.getComponent()
        # Set absolute sizes
        if relativeHeight < 0.0:
            component.setHeight(h)
        if relativeWidth < 0.0:
            component.setWidth(w)
        # Set relative sizes
        if (relativeHeight >= 0.0) or (relativeWidth >= 0.0):
            # One or both is relative
            self.handleComponentRelativeSize(cd)

    _runningLayout = False

    def runDescendentsLayout(self, container):
        """Causes a re-calculation/re-layout of all paintables in a container.

        @param container
        """
        if self._runningLayout:
            return
        self._runningLayout = True
        self.internalRunDescendentsLayout(container)
        self._runningLayout = False

    def forceLayout(self):
        """This will cause re-layouting of all components. Mainly used for
        development. Published to JavaScript.
        """
        set = set()
        for cd in self._idToPaintableDetail.values():
            set.add(cd.getComponent())
        Util.componentSizeUpdated(set)

    def internalRunDescendentsLayout(self, container):
        # getConsole().log(
        # "runDescendentsLayout(" + Util.getSimpleName(container) + ")");
        childWidgets = container
        while childWidgets.hasNext():
            child = childWidgets.next()
            if isinstance(child, Paintable):
                if self.handleComponentRelativeSize(child):
                    # Only need to propagate event if "child" has a relative
                    # size

                    if isinstance(child, ContainerResizedListener):
                        child.iLayout()
                    if isinstance(child, HasWidgets):
                        childContainer = child
                        self.internalRunDescendentsLayout(childContainer)
            elif isinstance(child, HasWidgets):
                # propagate over non Paintable HasWidgets
                self.internalRunDescendentsLayout(child)

    def handleComponentRelativeSize(self, *args):
        """Converts relative sizes into pixel sizes.

        @param child
        @return true if the child has a relative size
        ---
        Converts relative sizes into pixel sizes.

        @param child
        @return true if the child has a relative size
        """
        _0 = args
        _1 = len(args)
        if _1 == 1:
            if isinstance(_0[0], ComponentDetail):
                cd, = _0
                if cd is None:
                    return False
                debugSizes = False
                relativeSize = cd.getRelativeSize()
                if relativeSize is None:
                    return False
                widget = cd.getComponent()
                horizontalScrollBar = False
                verticalScrollBar = False
                parent = Util.getLayout(widget)
                # Parent-less components (like sub-windows) are relative to browser
                # window.
                if parent is None:
                    renderSpace = RenderSpace(Window.getClientWidth(), Window.getClientHeight())
                else:
                    renderSpace = parent.getAllocatedSpace(widget)
                if relativeSize.getHeight() >= 0:
                    if renderSpace is not None:
                        if renderSpace.getScrollbarSize() > 0:
                            if relativeSize.getWidth() > 100:
                                horizontalScrollBar = True
                            elif relativeSize.getWidth() < 0 and renderSpace.getWidth() > 0:
                                offsetWidth = widget.getOffsetWidth()
                                width = renderSpace.getWidth()
                                if offsetWidth > width:
                                    horizontalScrollBar = True
                        height = renderSpace.getHeight()
                        if horizontalScrollBar:
                            height -= renderSpace.getScrollbarSize()
                        if self._validatingLayouts and height <= 0:
                            self._zeroHeightComponents.add(cd.getComponent())
                        height = (height * relativeSize.getHeight()) / 100.0
                        if height < 0:
                            height = 0
                        if debugSizes:
                            VConsole.log('Widget ' + Util.getSimpleName(widget) + '/' + self.getPid(widget.getElement()) + ' relative height ' + relativeSize.getHeight() + '% of ' + renderSpace.getHeight() + 'px (reported by ' + Util.getSimpleName(parent) + '/' + ('?' if parent is None else parent.hashCode()) + ') : ' + height + 'px')
                        widget.setHeight(height + 'px')
                    else:
                        widget.setHeight(relativeSize.getHeight() + '%')
                        VConsole.error(Util.getLayout(widget).getClass().getName() + ' did not produce allocatedSpace for ' + widget.getClass().getName())
                if relativeSize.getWidth() >= 0:
                    if renderSpace is not None:
                        width = renderSpace.getWidth()
                        if renderSpace.getScrollbarSize() > 0:
                            if relativeSize.getHeight() > 100:
                                verticalScrollBar = True
                            elif (
                                relativeSize.getHeight() < 0 and renderSpace.getHeight() > 0 and widget.getOffsetHeight() > renderSpace.getHeight()
                            ):
                                verticalScrollBar = True
                        if verticalScrollBar:
                            width -= renderSpace.getScrollbarSize()
                        if self._validatingLayouts and width <= 0:
                            self._zeroWidthComponents.add(cd.getComponent())
                        width = (width * relativeSize.getWidth()) / 100.0
                        if width < 0:
                            width = 0
                        if debugSizes:
                            VConsole.log('Widget ' + Util.getSimpleName(widget) + '/' + self.getPid(widget.getElement()) + ' relative width ' + relativeSize.getWidth() + '% of ' + renderSpace.getWidth() + 'px (reported by ' + Util.getSimpleName(parent) + '/' + ('?' if parent is None else self.getPid(parent)) + ') : ' + width + 'px')
                        widget.setWidth(width + 'px')
                    else:
                        widget.setWidth(relativeSize.getWidth() + '%')
                        VConsole.error(Util.getLayout(widget).getClass().getName() + ' did not produce allocatedSpace for ' + widget.getClass().getName())
                return True
            else:
                child, = _0
                return self.handleComponentRelativeSize(self._idToPaintableDetail.get(self.getPid(child.getElement())))
        else:
            raise ARGERROR(1, 1)

    def getRelativeSize(self, widget):
        """Gets the specified Paintables relative size (percent).

        @param widget
                   the paintable whose size is needed
        @return the the size if the paintable is relatively sized, -1 otherwise
        """
        return self._idToPaintableDetail.get(self.getPid(widget.getElement())).getRelativeSize()

    def getResource(self, name):
        """Gets a recource that has been pre-loaded via UIDL, such as custom
        layouts.

        @param name
                   identifier of the resource to get
        @return the resource
        """
        return self._resourcesMap[name]

    def getContextMenu(self):
        """Singleton method to get instance of app's context menu.

        @return VContextMenu object
        """
        if self._contextMenu is None:
            self._contextMenu = VContextMenu()
            DOM.setElementProperty(self._contextMenu.getElement(), 'id', 'PID_VAADIN_CM')
        return self._contextMenu

    def translateVaadinUri(self, uidlUri):
        """Translates custom protocols in UIDL URI's to be recognizable by browser.
        All uri's from UIDL should be routed via this method before giving them
        to browser due URI's in UIDL may contain custom protocols like theme://.

        @param uidlUri
                   Vaadin URI from uidl
        @return translated URI ready for browser
        """
        if uidlUri is None:
            return None
        if uidlUri.startswith('theme://'):
            themeUri = self._configuration.getThemeUri()
            if themeUri is None:
                VConsole.error('Theme not set: ThemeResource will not be found. (' + uidlUri + ')')
            uidlUri = themeUri + (uidlUri[7:])
        if uidlUri.startswith('app://'):
            uidlUri = self.getAppUri() + (uidlUri[6:])
        return uidlUri

    def getThemeUri(self):
        """Gets the URI for the current theme. Can be used to reference theme
        resources.

        @return URI to the current theme
        """
        return self._configuration.getThemeUri()

    def NotificationRedirect(ApplicationConnection_this, *args, **kwargs):

        class NotificationRedirect(VNotification.EventListener):
            """Listens for Notification hide event, and redirects. Used for system
            messages, such as session expired.
            """
            _url = None

            def __init__(self, url):
                self._url = url

            def notificationHidden(self, event):
                ApplicationConnection_this.redirect(self._url)

        return NotificationRedirect(*args, **kwargs)

    # Extended title handling

    def getTooltipTitleInfo(self, titleOwner, key):
        """Data showed in tooltips are stored centrilized as it may be needed in
        varios place: caption, layouts, and in owner components themselves.

        Updating TooltipInfo is done in updateComponent method.
        """
        if None is titleOwner:
            return None
        cd = self._idToPaintableDetail.get(self.getPid(titleOwner))
        if None is not cd:
            return cd.getTooltipInfo(key)
        else:
            return None

    def handleTooltipEvent(self, *args):
        """Component may want to delegate Tooltip handling to client. Layouts add
        Tooltip (description, errors) to caption, but some components may want
        them to appear one other elements too.

        Events wanted by this handler are same as in Tooltip.TOOLTIP_EVENTS

        @param event
        @param owner
        ---
        Component may want to delegate Tooltip handling to client. Layouts add
        Tooltip (description, errors) to caption, but some components may want
        them to appear one other elements too.

        Events wanted by this handler are same as in Tooltip.TOOLTIP_EVENTS

        @param event
        @param owner
        @param key
                   the key for tooltip if this is "additional" tooltip, null for
                   components "main tooltip"
        """
        _0 = args
        _1 = len(args)
        if _1 == 2:
            event, owner = _0
            self._tooltip.handleTooltipEvent(event, owner, None)
        elif _1 == 3:
            event, owner, key = _0
            self._tooltip.handleTooltipEvent(event, owner, key)
        else:
            raise ARGERROR(2, 3)

    def addPngFix(self, el):
        """Adds PNG-fix conditionally (only for IE6) to the specified IMG -element.

        @param el
                   the IMG element to fix
        """
        # Helper to run layout functions triggered by child components with a
        # decent interval.

        b = BrowserInfo.get()
        if b.isIE6():
            Util.addPngFix(el)

    class layoutTimer(Timer):
        _isPending = False

        def schedule(self, delayMillis):
            if not self._isPending:
                super(_11_, self).schedule(delayMillis)
                self._isPending = True

        def run(self):
            VConsole.log('Running re-layout of ' + ApplicationConnection_this._view.getClass().getName())
            ApplicationConnection_this.runDescendentsLayout(ApplicationConnection_this._view)
            self._isPending = False

    def requestLayoutPhase(self):
        """Components can call this function to run all layout functions. This is
        usually done, when component knows that its size has changed.
        """
        self.layoutTimer.schedule(500)

    _windowName = None

    def setWindowName(self, newName):
        """Reset the name of the current browser-window. This should reflect the
        window-name used in the server, but might be different from the
        window-object target-name on client.

        @param stringAttribute
                   New name for the window.
        """
        self._windowName = newName

    def getWindowName(self):
        return self._windowName

    def getUidlSecurityKey(self):
        return self._uidlSecurityKey

    def captionSizeUpdated(self, component):
        """Use to notify that the given component's caption has changed; layouts may
        have to be recalculated.

        @param component
                   the Paintable whose caption has changed
        """
        self._componentCaptionSizeChanges.add(component)

    def getView(self):
        """Gets the main view, a.k.a top-level window.

        @return the main view
        """
        return self._view

    def registerTooltip(self, paintable, key, tooltip):
        """If component has several tooltips in addition to the one provided by
        {@link com.vaadin.ui.AbstractComponent}, component can register them with
        this method.
        <p>
        Component must also pipe events to
        {@link #handleTooltipEvent(Event, Paintable, Object)} method.
        <p>
        This method can also be used to deregister tooltips by using null as
        tooltip

        @param paintable
                   Paintable "owning" this tooltip
        @param key
                   key assosiated with given tooltip. Can be any object. For
                   example a related dom element. Same key must be given for
                   {@link #handleTooltipEvent(Event, Paintable, Object)} method.

        @param tooltip
                   the TooltipInfo object containing details shown in tooltip,
                   null if deregistering tooltip
        """
        componentDetail = self._idToPaintableDetail.get(self.getPid(paintable))
        componentDetail.putAdditionalTooltip(key, tooltip)

    def getConfiguration(self):
        """Gets the {@link ApplicationConfiguration} for the current application.

        @see ApplicationConfiguration
        @return the configuration for this application
        """
        return self._configuration

    def hasEventListeners(self, paintable, eventIdentifier):
        """Checks if there is a registered server side listener for the event. The
        list of events which has server side listeners is updated automatically
        before the component is updated so the value is correct if called from
        updatedFromUIDL.

        @param eventIdentifier
                   The identifier for the event
        @return true if at least one listener has been registered on server side
                for the event identified by eventIdentifier.
        """
        return self._idToPaintableDetail.get(self.getPid(paintable)).hasEventListeners(eventIdentifier)

    @classmethod
    def addGetParameters(cls, uri, extraParams):
        """Adds the get parameters to the uri and returns the new uri that contains
        the parameters.

        @param uri
                   The uri to which the parameters should be added.
        @param extraParams
                   One or more parameters in the format "a=b" or "c=d&e=f". An
                   empty string is allowed but will not modify the url.
        @return The modified URI with the get parameters in extraParams added.
        """
        if (extraParams is None) or (len(extraParams) == 0):
            return uri
        # RFC 3986: The query component is indicated by the first question
        # mark ("?") character and terminated by a number sign ("#") character
        # or by the end of the URI.
        fragment = None
        hashPosition = uri.find('#')
        if hashPosition != -1:
            # Fragment including "#"
            fragment = uri[hashPosition:]
            # The full uri before the fragment
            uri = uri[:hashPosition]
        if uri.contains('?'):
            uri += '&'
        else:
            uri += '?'
        uri += extraParams
        if fragment is not None:
            uri += fragment
        return uri


class UidlRequestCallback(RequestCallback):

    def __init__(self, uri, payload, synchronous, connection):
        super(UidlRequestCallback, self).__init__()
        self._uri = uri
        self._payload = payload
        self._synchronous = synchronous
        self._conn = connection


    def onError(self, request, exception):
        self._conn.showCommunicationError(exception.getMessage())
        self._conn.endRequest()
        if not self._conn.applicationRunning:
            # start failed, let's try to start the next app
            ApplicationConfiguration.startNextApplication()


    def onResponseReceived(self, request, response):
        VConsole.log('Server visit took '
            + str(time() - self._conn._requestStartTime.getTime())
            + 'ms')

        statusCode = response.getStatusCode()

        if statusCode == 0:
            self._conn.showCommunicationError('Invalid status code 0 (server down?)')
            self._conn.endRequest()
            return
        elif statusCode == 401:
            self._conn.showAuthenticationError('')
            self._conn.endRequest()
            return
        elif statusCode == 503:
            delay = int(response.getHeader('Retry-After'))
            VConsole.log('503, retrying in ' + delay + 'msec')

            timer = UidlTimer(self._uri, self._payload, self._synchronous,
                    self._conn)
            timer.schedule(delay)
            return

        if statusCode / 100 == 4:
            # Handle all 4xx errors the same way as (they are
            # all permanent errors)
            self._conn.showCommunicationError('UIDL could not be read from '
                'server. Check servlets mappings. Error code: ' + statusCode)
            self._conn.endRequest()
            return

        start = datetime()
        # for(;;);[realjson]
        jsonText = response.getText()[9:len(response.getText()) - 1]
        try:
            json = self._conn.parseJSONResponse(jsonText)
        except Exception, e:
            self._conn.endRequest()
            self._conn.showCommunicationError(e.getMessage()
                    + ' - Original JSON-text:' + jsonText)
            return

        VConsole.log('JSON parsing took ' + (time() - start.getTime()) + 'ms')

        if self._conn.applicationRunning:
            self._conn.handleReceivedJSONMessage(start, jsonText, json)
        else:
            self._conn.applicationRunning = True
            self._conn.handleWhenCSSLoaded(jsonText, json)
            ApplicationConfiguration.startNextApplication()


class UidlTimer(Timer):

    def __init__(self, uri, payload, synchronous, connection):
        super(UidlTimer, self).__init__()
        self._uri = uri
        self._payload = payload
        self._synchronous = synchronous
        self._conn = connection

    def run(self):
        self._conn._activeRequests -= 1
        self._conn.doUidlRequest(self._uri, self._payload, self._synchronous)
